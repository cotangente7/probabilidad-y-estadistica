# -*- coding: utf-8 -*-
"""Copy of notebook_clase_2024.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UasXMSMOPtzKOXcddTzDa-iELGdz2796

# Visualización de datos con gráficos simples

En esta notebook recorremos distintos tipos básicos de grafícos que pueden utilizarse en el análisis de datos, con aplicaciones prácticas. Nos centraremos no sólo el código para generarlos, sino también en algunos pequeños trucos para lograr gráficos más legibles.

Es importante recordar que, a pesar de que esta notebook utiliza los datos para ejemplificar los gráficos, en la aplicación real de la ciencia de datos ocurre lo contrario. Debemos pensar primero en la pregunta a responder, y luego diseñar la visualización. Esto incluye:

1. Encontrar el gráfico adecuado para los datos
2. Agrupar los datos de manera que resalten el patrón que ayuda a responder la pregunta inicial.
3. Encontrar los encodings visuales más efectivos para comunicar este patrón (aunque no vamos a hablar tanto de eso en esta notebook).

## 1. Tablas

Las tablas son muchas veces dejadas de lado en las visualizaciones, pero son una de las formas de representación más poderosa. Usualmente partimos de una tabla para generar visualizaciones más complejas, pero esto no significa que generar buenas tablas no sea útil en el proceso de comunicación.

* Muestran cantidades exactas
* Representan cualquier tipo de datos
* Son de acceso universal
* Son fáciles de crear
* Permiten comprar muchas variables

Lo primero que tenemos que hacer para comenzar a enteder el dataset es ver los valores como una tabla, para indentificar la información en cada una de las columnas.

Empecemos levantando una tabla creada en excel

# ¿Cómo leer datos desde pandas?

En esta primera notebook, aprendemos cómo cargar un conjunto de datos utilizando pandas y cómo ver su contenido.
"""

import io
import pandas
import seaborn

print(seaborn.__version__)
BLUE = '#35A7FF'
RED = '#FF5964'
GREEN = '#6BF178'
YELLOW = '#FFE74C'
# Con esto hacemos los gráficos más grandes, adecuados para las presentaciones.
#seaborn.set_context(context='talk', font_scale=1.2)

"""Si cargan el archivo desde su disco duro a el temporario de colab, pueden correr la siguiente sentencia para armar un dataframe de pandas"""

new_df = pandas.read_excel('/content/Dataset AyVD 2020 (respuestas).xlsx')

"""Si no hacen eso, pueden levantar el archivo desde su disco en la computadora personal y subirlo al temporario con las siguientes sentencias"""

from google.colab import files
uploaded = files.upload()

"""Una vez subido el archivo, éste está disponible en la variable `uploaded`, que es un diccionario. Casi siempre, la clave que estamos buscando es el nombre del archivo que acabamos de subir, pero podría no ser el caso. Para estar seguro, vamos a listar los archivos que se subieron."""

print(uploaded.keys())

"""Una vez que tenemos la clave correspondiente, obtenemos el contenido del archivo. Como es un archivo excel usamos read_excel de pandas"""

new_df = pandas.read_excel('/content/Dataset AyVD 2020 (respuestas).xlsx')

"""Si queremos bajarlo como csv, lo traducimos a csv y lo bajmos a disco"""

df.to_csv('Dataset AyVD 2020 (respuestas)_cvs.csv')
files.download('Dataset AyVD 2020 (respuestas)_cvs.csv')

file_key = '/content/Dataset AyVD 2020 (respuestas)_cvs.csv'
df2 = pandas.read_csv(file_key)

"""Ambos archivos df y df2 son iguales."""

new_df= pandas.read_csv('/content/Dataset AyVD 2020 (respuestas)_cvs (1).csv')

"""Con esta operación, hemos creado un DataFrame de pandas en base al archivo de respuestas. Un DataFrame no es más que una tabla sobre la cual podemos aplicar un montón de operaciones similares a las de Excel o a las SQL. En esta notebook no pretendemos hacer un tutorial de pandas, el Internet está lleno de ellos, pero sí iremos explicando cómo implementar determinadas operaciones necesarias para el análisis de este conjunto de datos.

Veamos qué tiene adentro el DataFrame `df`.
"""

new_df[:10]

"""## Variables


Para trabajar más cómodamente, renombraremos las columnas de DataFrame. Tengan cuidado de que el orden de los nombres nuevos se corresponda con el contenido de cada columna.
"""

new_df.columns = ['index' , 'timestamp', 'gender', 'age', 'zodiac_sign', 'profession', 'junior_programmer_salary', 'senior_programmer_salary']

"""También pandas nos permite otras operaciones simples de estadística descriptiva. En la siguiente línea, estamos filtrando las filas que se identifican como *Hombres* y describiendo la distribución de la columna *Cuánto creés que gana por mes un programador (con dos o menos años de experiencia) en la industria argentina?*"""

# Descripción de la distribución de la variable "Cuánto creés que gana por
#mes un programador (con dos o menos años de experiencia) en la industria argentina?"
# solo en los registros donde "Me identifico" tiene el valor Hombre
new_df[new_df.gender == 'Hombre'].junior_programmer_salary.describe()

new_df[new_df.gender == 'Hombre'].senior_programmer_salary.describe()

"""Con un cálculo grosero, quien ganaba 50 mil pesos en el 2020 ahora gana 1 millon cuatrocientos. Si le aumentaron la inflación.

"""









"""# Tipos de datos

## Tipos de variables aleatorias

En base a la definición de variable aleatoria que vimos en el teórico, podemos hablar de que cada columna de nuestro dataset es un **variable aleatoria**, y que su valor en cada respuesta es una **realización** de dicha variable. Pero, ¿qué tipo tienen esas variables?

Tenemos que distinguir dos conceptos con el mismo nombre y significado similar, pero que no son iguales:
 - **tipo de la variable aleatoria** es el tipo teórico que tienen nuestros datos.
 - **tipo de datos** es un concepto de programación que indica en qué formato se representa la información.

### Rango y valores posibles

Siempre es útil saber qué valores puede tomar una variable para entender qué tipo tiene. Sin embargo, si sospechamos que una variable es continua, no tiene sentido listar todos sus valores posibles. En ese caso, nos conviene mostrar sólo el rango, o tomar una pequeña muestra. Veamos algunos ejemplos:

df.gender.unique()  # Listar todos los valores posibles
"""

new_df.age.max(), new_df.age.min()  # Variable numérica

new_df.junior_programmer_salary.sample(n=10)  # Tomamos una muestra

new_df.profession.unique()[:10]

"""## Tipos de datos en programación

Ahora pasemos al tipo de datos. Podemos saber con Pandas cómo está guardando la información de cada columna:
"""

new_df.dtypes

"""En este caso, el tipo object hace referencia a un string, pero también podría ser una fecha, una lista, o cualquier cosa más compleja que un número. El tipo de datos no siempre se correlaciona con el tipo de la variable. Por ejemplo, si guardamos un puntaje de satisfacción del 1 al 5, aunque usemos números, esa variable es conceptualmente ordinal y no numérica."""



"""## Probabilidad

Antes de hablar de probabilidad condicional entre dos variables, tenemos que encontrar un método para calcular la probabilidad de cada evento por separado. En el teórico vimos que si cada una de nuestros eventos es independiente e idénticamente distribuido, es decir, que $P(\{a_i\})=1/k$, entonces la probabilidad de un conjunto $A \subset \Omega$ es la proporción de $A$.

$$P(\{a_i\})=1/k \implies P(A)=|A|/|\Omega|=|A|/k$$

Calculemos entonces la probabilidad del evento *gender=Mujer*. Nuestro $\Omega$ son todas las respuestas del dataset, cada $a_i$ es una variable que representa una respuesta, y el conjunto $A$ son las respuestas en la que la columna gender tiene el valor "Mujer".
"""

p_mujer = len(new_df[new_df.gender == 'Mujer']) / len(df)
p_mujer

"""### Graficar la frecuencia y la probabilidad

Podemos comparar visualmente la frecuencia de distintos conjuntos de datos de manera muy fácil. Con esto también veremos el primer tipo de gráficos: el *gráfico de barras*.

Elegimos este tipo de gráfico porque nos permite representar cantidades numéricas, en este caso la frecuencia o la probabilidad, correspondientes a distintos valores categóricos, por ejemplo el género.

Este gráfico es tan útil, que Seaborn, la librería para visualizaciones que usaremos, trae un método que cuenta los distintos valores posibles por nosotros.
"""

import seaborn
import matplotlib.pyplot as plt

seaborn.countplot(new_df.gender, color='steelblue')

"""Para calcular la probabilidad en lugar de la frecuencia de todos las respuestas posibles para cada columna de una forma más sencilla con la operación value_counts de pandas."""

data = new_df['gender'].value_counts(normalize=True).reset_index()
data

"""Dibujamos directamente sobre pandas"""

data.plot(x='gender', y='proportion', kind='barh', color=seaborn.palettes.mpl_palette('Dark2'))

"""## Probabilidad condicional

Ahora podemos pasar a hablar de la probabilidad condicional. La definimos como

$$P(A|B) = \frac{P(A \cap B)}{P(B)}$$

Esto es equivalente a:

$$P(A|B) = \frac{|A \cap B|}{|B|}$$

## Ejemplo 1

Calcular la probabilidad de que una respuesta tenga *gender=Mujer* dado que sabemos que tiene *zodiac_sign=Aries*
"""

count_mujer_dado_aries = len(new_df[(new_df.gender == 'Mujer') & (df.zodiac_sign == 'Aries')])/len(new_df[new_df.zodiac_sign == 'Aries'])

print(count_mujer_dado_aries)

"""Ejercicio 1
Calcular la probabilidad de que una respuesta tenga gender=Hombre dado que sabemos que tiene zodiac_sign=Tauro
"""

total_tauro = new_df[new_df['zodiac_sign'] == 'Tauro'].shape[0]
hombres_tauro = new_df[(new_df['zodiac_sign'] == 'Tauro') & (new_df['gender'] == 'Hombre')].shape[0]
if total_tauro > 0:
    probabilidad = hombres_tauro / total_tauro
    print(f"P(Hombre | Tauro) = {probabilidad:.4f}")
else:
    print("No hay datos suficientes para calcular la probabilidad.")

"""## Independencia

Ahora, para saber si dos conjuntos son independientes, tenemos que comprobar si $P(A|B) = P(A)$ ó $P(A\cap B) = P(A)*P(B)$.

Ejercicio 2

Calcular si los conjuntos de respuestas con *gender=Mujer* y *zodiac_sign=Aries* son independientes o no, utilizando ambos métodos.
"""

import pandas as pd
import scipy.stats as stats

# Calcular probabilidades individuales
total_respuestas = new_df.shape[0]
p_mujer = (new_df['gender'] == 'Mujer').mean()
p_aries = (new_df['zodiac_sign'] == 'Aries').mean()

# Calcular probabilidad conjunta P(Mujer ∩ Aries)
p_mujer_aries = ((new_df['gender'] == 'Mujer') & (new_df['zodiac_sign'] == 'Aries')).mean()
independencia = abs(p_mujer_aries - (p_mujer * p_aries)) < 1e-4

print(f"P(Mujer) = {p_mujer:.4f}")
print(f"P(Aries) = {p_aries:.4f}")
print(f"P(Mujer ∩ Aries) = {p_mujer_aries:.4f}")
print(f"P(Mujer) * P(Aries) = {(p_mujer * p_aries):.4f}")
print(f"¿Son independientes? {'Sí' if independencia else 'No'}")

# Método 2: Prueba de independencia con chi-cuadrado
tabla_contingencia = pd.crosstab(new_df['gender'], new_df['zodiac_sign'])
chi2, p_valor, _, _ = stats.chi2_contingency(tabla_contingencia)
print(f"Valor de chi-cuadrado: {chi2:.4f}")
print(f"P-valor: {p_valor:.4f}")
if p_valor < 0.05:
    print("Conclusión: Hay evidencia suficiente para decir que NO son independientes.")
else:
    print("Conclusión: No hay evidencia suficiente para rechazar la independencia.")

"""# Distribuciones
## Funciones de densidad

Vimos en el teórico los conceptos de funciones de densidad y cómo varían según el tipo de datos. A pesar de que estos conceptos son muy similares, la hora de visualizarlos, tenemos que usar herramientas muy distintas.
### Densidad de probabilidad de variables categóricas

Ya vimos anteriormente cómo calcular esta probabilidad y cómo representarla usando gráficos de barra. Los gráficos de linea o gráficos de puntos no son apropiados porque implican secuencialidad en los datos.

Esta es otra manera de calcular la densidad de probabilidad:

"""

data = new_df.profession.value_counts(normalize=True)
seaborn.set_theme(style="darkgrid")
plt.figure(figsize=(15, 6))
seaborn.barplot(x=data.index, y=data.values, color='steelblue')
plt.xticks(rotation=90)

"""Pongamos las cosas en proporción. Muchas veces cambiar los ejes de los gráficos produce resultados muy distintos"""

data = new_df.profession.value_counts(normalize=True)
plt.figure(figsize=(15, 6))
seaborn.barplot(x=data.index, y=data.values, color='steelblue')
plt.xticks(rotation=90)
plt.ylim(0, 1)

"""### Densidad de probabilidad para variables numéricas discretas

En el caso de las variables numéricas y ordinales, se pueden usar tanto gráficos de barra como gráficos de línea. Veamos que resultado podemos obtener
"""

color = (0.2, # redness
         0.4, # greenness
         0.2, # blueness
         0.6 # transparency
         )
color2 = ['lightblue', 'blue', 'purple', 'red', 'black']
data = new_df.age.value_counts(normalize=True)
seaborn.color_palette("flare")
plt.figure(figsize=(15, 6))
seaborn.barplot(x=data.index, y=data.values,color=color)

data = new_df.age.value_counts(normalize=True)
plt.figure(figsize=(15, 6))
seaborn.lineplot(x=data.index, y=data.values, color='purple')

"""
En ambos gráficos, ¿están todos los valores representados? ¿qué sucedió con los valores faltantes? ¿Podríamos usar este tipo de gráfico si la variable pudiera tomar miles de valores posibles?

La forma más adecuada de representar esta infomación para variables numéricas es el histograma, que separa el rango completo de valores en contenedores (bins) ancho constante y cuenta cuántos ejemplos caen dentro de cada contenedor.

En muchos ejemplos de la web suele estar todavia el comando seaborn.displot pero ya ha sido reemplazado. Funciona pero chilla en agonía avisando que porto no va a estar mas disponible.




"""

seaborn.distplot(new_df.age, bins=15, kde=False, norm_hist=True, color ='red')

"""La nueva funcion es bastante parecida."""

seaborn.histplot(new_df.age, bins=15, kde=False, stat="density",color='forestgreen')

"""La función seaborn.distplot has sido cambiada por la funcion seaborn.histplot. Para qur muestre frecuencia y no conteo se le agrega la keyword stat="density":

Una forma todavía más fácil de hacer un histograma es usando pandas mismo, pero el control sobre los elementos gráficos es menor:
"""

new_df.age.hist(density=1)

"""## Función de densidad acumulada

Pandas permite graficar la FDA de cualquier columna numérica:
"""

## Función de densidad acumulada
new_df.age.hist(cumulative=True, density=1)

seaborn.ecdfplot(new_df, x="age", hue="gender")

seaborn.ecdfplot(new_df, x="age", hue="profession")

dataset=new_df.copy()

"""Los gráficos de barra son lo más adecuados para ver las variables categorícas, por ejemplo, el género. Además de eso, necesitamos seleccionar una variable aleatoria con datos numéricos para poder graficar en el eje y. Tomemos la estimación del sueldo para juniors. Veamos cómo se construye uno de estos gráficos:"""

seaborn.set_theme(style="darkgrid")
plt.figure(figsize=(15, 6))
seaborn.barplot(data=dataset, x='gender', y='junior_programmer_salary')

"""En este gráfico estamos usando la altura de las barras para representar el promedio de las estimaciones de salario para cada uno de los grupos. Sin embargo, esto no es evidente a primera vista. El usuario no tiene suficiente información para inferir el significado del eje vertical. Hay que tener en cuenta que muchas veces, **el nombre original de la columna no representa la información agregada**.

Por otra parte, ¿qué significan las líneas negras? Son los intervalos de confianza, que tienen un valor por default de 95. Indica que el verdadero valor poblacional del estadístico se encuentra en ese rango, con una confianza del 95%. Por eso vemos que (probablemente) para varones y mujeres, el rango es mucho más pequeño, ya que la muestra es mucho más grande. Para otros grupo minoritario, no tenemos certeza del valor real de la media poblacional porque la muestra es demasiado pequeña.

Este estadísico suele ser difícil de interpretar para quienes no son expertos en estadística, puede ser conveniente reemplazarlo por la desviación estándar de la muestra. Si bien estamos usando la misma codificación visual (las rayitas negras), los valores que representamos son completamente distintos. Si usamos un intervalo de confianza, estamos hablando de la distribución del estimador de la media poblacional, que es una variable aleatorio que toma valores en todas las muestras posibles. Por otro lado, si usamos la desviación estándar, estamos hablando del valor del estadístico en esta muestra.

Con esas observaciones, podemos construir un gráfico más representativo.
"""

plt.figure(figsize=(15,6))
seaborn.barplot(data=dataset, x='gender', y='junior_programmer_salary',
                color=BLUE, errorbar='sd')
plt.ylabel('Promedio de la estimación \n por grupo')
plt.xlabel('Género')
plt.title('Comparación entre las estimaciones \n de sueldo para programadores junior')
seaborn.despine(left=True)

"""### 2.1 Agrupaciones

Es muy útil poder comparar también más de una variable categórica a la vez. Para ello, podemos usar el atributo `hue` de los gráficos de barra.

En general, conviene agrupar por la variable que tengan menos categorías. Entonces, si queremos comparar las estimaciones de sueldo con respecto la profesión y el género, conviene agrupar por género, que sólo puede tener 4 variables posbiles.
"""

plt.figure(figsize=(10,6))
seaborn.barplot(data=dataset, x='profession', y='junior_programmer_salary',
                hue='gender', errorbar=None)
plt.ylabel('Promedio de la estimación \n por grupo')
plt.xlabel('Profesión')
plt.title('Comparación entre las estimaciones \n de sueldo para programadores junior')
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
seaborn.despine(left=True)

"""¡El primer gráfico nos queda un desastre! Esto ocurre porque:
1. No podemos leer las etiquetas del eje x. Por suerte, esto es muy fácil de solucionar agregando `plt.xticks(rotation=90)`
1. La cantidad de valores para el campo profesión son demasiadas para un gráfico. Esto es solucionable: o bien manualmente agrupamos las categorías en valores estándar, o nos limitamos sólo a graficar las categorías con más datos.
1. No tenemos suficientes puntos para generar columnas para todas las combinaciones. Esta limitación es más difícil de solucionar, y puede indicarnos que este no es el método adecuado para representar esta información.
4. ¿Se les ocurren más?

Tratemos entonces con un gráfico que sí tenga sentido: dada la cantidad de respuestas, esperamos tener suficientes ejemplos para los dos géneros más populares y para casi todos los signos del zodiaco (a pesar de que no saquemos ninguna información útil de graficar esto).
"""

plt.figure(figsize=(10,6))
seaborn.barplot(data=dataset, x='zodiac_sign', y='junior_programmer_salary',
                hue='gender', errorbar='sd')
plt.ylabel('Promedio de la estimación \n por grupo')
plt.xlabel('Signo zodiacal')
plt.title('Comparación entre las estimaciones \n de sueldo para programadores junior')
plt.xticks(rotation=90)
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
seaborn.despine(left=True)

"""### 2.2 Countplot

Otro gráfico de barra muy útil es el que en el eje vertical tiene el conteo de la cantidad de registros en una categoría. ¡Seaborn puede graficar esto muy fácilmente!
"""

plt.figure(figsize=(15,6))
seaborn.countplot(data=dataset, x='gender')

"""## 3. Histogramas

Muestra la distribución de una variable numérica, dividiendo las variables en segmentos (*bins*) o estimando una función de densidad. Ojo, ¡no es lo mismo que un gráfico de barras!

Por ejemplo, podemos graficar con más precisión la distribución de la variable *junior_programmer_salary*.
"""

plt.figure(figsize=(15,6))
plt.title('Distribución de las estimaciones \n de sueldo para programadores junior')
seaborn.histplot(dataset.junior_programmer_salary.dropna(), kde=True, bins=40)
seaborn.despine()

"""### 3.1 Outliers

Es muy probable que encontremos outliers en nuestro dataset que complican la visualización.

Una forma de calcular los outliers es con los percentiles o dejando sólo los que se encuentran en un rango de X desviaciones estándares de la media.
"""

def clean_outliers(dataset, column_name):
    """Returns dataset removing the outlier rows from column @column_name."""
    interesting_col = dataset[column_name]
    # Here we can remove the outliers from both ends, or even add more restrictions.
    mask_salarios_outlier = (
        numpy.abs(interesting_col - interesting_col.mean()) <= (2.5 * interesting_col.std()))
    return dataset[mask_salarios_outlier]

data = clean_outliers(dataset, "junior_programmer_salary").junior_programmer_salary
print("Filas removidas", len(dataset) - len(data))
print("Salario máximo considerado", data.max())

plt.figure(figsize=(15,6))
seaborn.histplot(data, bins=40)
seaborn.despine()

"""### 3.2 Múltiples histogramas

¡Podemos finalmente comparar las distribuciones de los salarios para seniors y para juniors! Graficaremos dos histogramas, uno por encima del otro.
"""

seaborn.histplot(
    dataset.junior_programmer_salary, label='Junior',kde='True')
seaborn.histplot(
    dataset.senior_programmer_salary, label='Senior',kde='True')
plt.legend()

"""## Ejercicio 1

* Limpiar el gráfico anterior para hacerlo más legible. Por ejemplo, agregar título y etiquetas, remover los outliers, agrandar el tamaño, cambiar el color. etc.
* Experimentar con distintos valores para el parámetro `bins`. ¿Cuál es el valor por defecto? ¿Qué sucede cuando es muy bajo? ¿Y cuando es muy alto?
* ¿A qué distribuciones de las vistas en clase se parece más cada histograma? ¿Son distintas? ¿Qué las diferencia?
"""

def to_categorical(column, bin_size=5, min_cut=15, max_cut=50):
    if min_cut is None:
        min_cut = int(round(column.min())) - 1
    value_max = int(numpy.ceil(column.max()))
    max_cut = min(max_cut, value_max)
    intervals = [(x, x + bin_size) for x in range(min_cut, max_cut, bin_size)]
    if max_cut != value_max:
        intervals.append((max_cut, value_max))
    print(intervals)
    return pandas.cut(column, pandas.IntervalIndex.from_tuples(intervals))

seaborn.countplot(to_categorical(dataset.age.dropna()), color=BLUE)
plt.xticks(rotation=45)

age_data = clean_outliers(dataset, "junior_programmer_salary")
age_data = age_data[~age_data.age.isnull()]
age_data['age_segment'] = to_categorical(age_data.age)

"""## Gráficos de caja

Muestra la distribución de una variable numérica, de una forma más condensada que un histograma. Son muy útiles para comparar muchas distribuciones, pero sólo cuando son muy distintas entre ellas, ya que oscurecen algunas sutilezas. Otros problema de este tipo de gráficos es que *no todo el mundo recuerda cómo leerlos*.

Por ejemplo, volvamos al ejemplo anterior para comparar la distribución de las estimaciones para el salario de un junior. Con un gráfico de caja, se vería de la siguiente manera:

![Diagrama_de_caja.jpg](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/2wBDAAQDAwQDAwQEAwQFBAQFBgoHBgYGBg0JCggKDw0QEA8NDw4RExgUERIXEg4PFRwVFxkZGxsbEBQdHx0aHxgaGxr/2wBDAQQFBQYFBgwHBwwaEQ8RGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhr/wAARCAHuA2EDASIAAhEBAxEB/8QAHQABAAIDAQEBAQAAAAAAAAAAAAYHAgUIBAEDCf/EAF0QAAEDAwICAQoQCwYEBAUFAQABAgMEBQYHERIhMQgTFDdBUXF0sdIVFhcYIjIzNVdhcpSVsrPTIzhSVVZzgZGWtNRCU2J1dpMkNJLRJTZUoSZDY4LiREVkhMHj/8QAGwEBAQADAQEBAAAAAAAAAAAAAAECAwQGBQf/xAA5EQEAAQMBBAgDBgUFAQAAAAAAAQIDEQQFEiExBjI1QVFxc7IiYaETFIGxwfAVM3KR0QcXI+HxQv/aAAwDAQACEQMRAD8A7+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACksx6p3EMdzmx4VZJUyG/wBxucFDOlLIiw0fXJEaqySc0Vyb+0Tde/sBdoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK21a1DueIssdiwyghumZZLUuprVT1DlbDEjG8UtRKqc+txt5qic13RCMP031hpadblR6vNq74jePsGpsMDbfI7+72b+Ea3ucW6r3djHWeoXBtRNP9SbhDJLjlpbWWy8SxsV/YUVSjOCoVE58DXsRHL3EcWbWah4nb7A6/1eSWmOytj672Z2YxY1btvyVF5+BOZFafSfUSTUPH6qW62/0HyK0VsltvVv4+JKeqj24uF3dY5FRzV7y/ET0pbqfoaq9S51ns9JNQUOYXpKq2QTsVj3UcUTYo5nNXoWThV23e2LpEIEVz7UfGdMrI+75rdYbbSpukbXLxSTO/IjYnsnu+JP27EqOSuqV6lG66i3aozDCrxUVl54PZ2m5VCuic1P7NO9fcvkr7FV7qGdEUzVEVTiFhRmtfVdZRqV2RaMQ6/iuMP3Y5I37VdU3/G9PaNX8lv7VUoKw3arxm92u82dYmV1sq46unWRnEzrjHI5vEndTdD5d7RcceulTasgoKm13OmdwzUtTGrJGL4F7neVOSnic5Gpu5URO+qnudPo9JTYmKOMTzlm6H9ezq3/AOosP0Yvnj17Orf/AKiw/Ri+ec69ei/vGf8AUg69F/eM/wCpDX/DtB+5MP6sdTVqLe9UtK6LI8sdTPuctXUwvWmh60zhZIrW+x3XuJ3y3jnbqJFRdBLaqLv/AOI1v2qnRJ4mqMTMQwnmAGMkjIY3ySvbHGxFc5zl2RETpVVIip861niw7VnCMM7GbNS3pXNudXsv/BOl4mUadP8A82WORnPvHzPuqDxnTrUSy4hkDaiNa+hmrJ6tlPNKlOjOFGN4I43K9XqruaL7Hh59KHPb7TqFrHhupWXYtjdrq6LMbgyqsdynvD6erp6a3ScNGscCQOTfjie/27eJZV6EXdZlW6tWWuy7QrVXIauG043dbBc6WprZF2gpa17YVWF7v7Ps4pWoq91igW9S5vQ3XV68WuLLGsix2zddqbFHSSNdxvfu+plkcxEc1reBrGscvNz1XnsiY4/1RmmGUXa2WuyZbTVFXdHI2h46eaKOoevRGyV7EYr+5wcXFvy235EJuNZT3Hqjb/WUMrZ6Wp0lilhlYu6PY6tqFa5PiVFRSmqfOMczXqXtPtN8QrortqFULao6Ogpo3PnoZoqmOR87+X4JrY2vVXrsmzunZdwOqMd1Lo79nea2mG9WiS2Y1BClTF1meGppJt5euumfIiRLHtH7FWKvtXKq7bH6YjrfgWeXv0GxPIY7lcHRvlja2mmYyZjF2c6OR7EZIibpzYqnP+r9hvWTZJ1R1rxWGeoulRidi63BBv1yZjXzukjaidKuja9qJz3322XfYtCl1WwbUTB67D9J79TOyCrxyqgtluiY9k1G5tOrWtkTb8ErV4U2cqc05b7ASuza76dZBkkePWfKaSquc0z4IESORsNRKzfiZFOrUikcmy8mOVSxTiiTKbBk+i2k2muEI5+fUNzszJ7UkD21donpXtdVVEzFTeNGq2Tdy7b8fLpO1wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD854IqmGSCojZNDI1WPje1HNc1eSoqLyVCt6bqetLKO7tutPgljZWtk641exUVjXd9I19gi+BCzAB8REaiNaiI1E2RE7h9AAAACvdU9FsR1ftfYmXW5HVUbVSluEGzKmnX/C/vf4V3aveOI7j1K+U6Zaq4e6vpGZXhs1+pGProoOJrY1maitqIufCiouyrzavf7h/R4G2i7XRTNNM8J5rlC/Ug09/QbGvoiDzR6kGnv6DY19EQeaTQGpGvs1iteOULaDH7dSWqha5XNp6SBsMaKq7qqNaiJuqmwAAAAAYvY2ROF7Ucm6LsqbmQA81xo0uFvq6Rz1jSohfErkTfh4mqm//ALkf04wmHTrBrBi9PVOrmWiijpG1L40Y6VGJyVURV28G5KQAMWsa1XOa1Ec5d3KidPhMgB8RrUcrkaiOVNlXbmp9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABz6utmdXa53pMYxfH32ygulVb45K67SxyvWCRY3OVrYlRN1aqpzXlsB0ECgPVW1S/RXEvpqo+4PvqrapforiX01UfcFxKZX8CgfVW1S/RXEvpqo+4NdfNdNRMYtVTeL1iWNPt1E1JKltNeJllWPiRF4EWFE358t1GJMujwYsdxNR2226bmRFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADljBPaZV/qu8fzch1OcsYJ7TKv8AVd4/m5DKElKwAZIEJ1g7WOT+Jr9ZpNiE6wdrHJ/E1+s0Dq+H3KP5KeQzMIfco/kp5DM1sgAAAAAAAAAAAAAAAAAAAAAAAAAAACAakawY3pnHBBdZZbhfKzlQWWgZ16sq3dxGxp0N/wATtkTvmNVUUxMzOIOadzTR00Mk1RIyGGNque97ka1rU5qqqvQhAcF1oxTUnKL9YsMrHXT0EiifU1sbf+He57nIjY3f29uBd1Tl3lUqarxjL9YZm1er1R6DY3xI+nxG3VC8L033RaydNllX/A3ZqHngx/ONPtRb7e9MbBjdVZ7nbaKiZT1dW6lSBIEf7VrGKmy8f/seEjpzsWrXzpIuxiImZrmcU58Invn6O37nd3N7DqMHP/qga3/ofhn0zN5hp8n1r1bwu1tu+R4hijba2qp4JlprrM+ROuytjRUarE35uTun27PSTY2ouU2rWpomqqcRETxmZaZsXYjM0umAAeiaAAAaq15Jar1cLzb7XWMqayy1LaW4RNRUWCV0TJWtXdOe7JGLum6c1TfdFRPlgye0ZRZY71Ya6OttciytZUtRUaqxvcx/SidDmOTf4u8cS2XP7pp7X6gZ5TTSz0+p0l5hsLEXfa5UlW6nomp8tki+HrX7pPhktDpdpFkOnGQZFktDV4/mKWm3txpyNuVwWoYypihhVU5dcWWRd927I1fZIB1ThWUenPHaa+MtlZaqesV7qaKtajJXwo5UZKrf7KPaiORF57OTfZeRIDlzR6TKspdq7p1fbzmFkZboaCez1l5uEct2t6VUUjvZVEL1R6NfCjkRXb8Kq13dP10FzLIteKy9XLJMlSip8bpHWBaOxV6sSrq3s2lublRE9i5PcN0VE2e5OaAdDY1lFqy+2uuOPVLqqjbUTUyvdC+L8JE9Y3pwvRF5Oaqb7bLtum6G4ONMcyHLLxgmkNsTM7/S1F3zW72quuLavrlVNSsdWNRiveioqo2NqI5UXhVEcmyohsaXDclr8h1jxZNUs5jt+GQUtXZJEuv4dstRSLMvXpuHjmY1zERGKu2yu7q7gddA5XsGYZLrTetL8YrL9dMdt9bgbMnvVRZ6nsWorZ3PZA2NsrU4mMRyueqN29siKvJCxdCb/dpbhqDiF7u9TkLMRvvYdFc6tyOnlp5IWStjleiJxvYrnNV3SvLcC4wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5YwT2mVf6rvH83IdTnLGCe0yr/Vd4/m5DKElKwAZIEJ1g7WOT+Jr9ZpNiE6wdrHJ/E1+s0Dq+H3KP5KeQzMIfco/kp5DM1sgAAAAAAAAAACnarT/AFdlqZn02sUEED5HOji9KdO7gaqrs3fj57Jsm/dLiAFMep3rF8M8H8IU3nkLsEWsV81FzDEPVYp4PS5DQy9lelamd1/shjnbcHEnDw8O3Su+/cOmyl8B/GK1g8Ssn2EhFffU71i+GeD+EKbzzfYdh+otnvsVXl+pMWS2tsb2voW49DSK9yp7F3XGuVU2XnttzLJBUAAAAAAAAeG80VTcbTW0lvuEtqqp4XRxVkLGvfA5U2R6NcitVU6dlQ5Ksdsq+p6vdfPqtbHXSO51CqufxcdQsvEvJlUjt3QbdHsfYeU7DPyqaaGsp5aerhjqKeVqskjkajmvavJUVF5KnxHyNrbKsbZ0lWkvzMU1eE4n9/KeDbauTaq3oVvR1lPcKWGqoJ4qqmnaj4poXo9j2r0KipyVD9HSxtXZz2NXvK5EIRfdD71gVVPedB6uKlgkestXidfIvYFQvdWB3TTvX4vY+BCuNPMTx/XHWXOpNSMRr6Oe3Wq3MS23GSSF9NNvK2TZY3Ij2rwps7oVOaH4N/thq4182Zu/8UxMxXjM+UxnhPz5PsfxCnczjiv3r8f97H/1oVZ1Q8sbtMKlGyMVfRO28kcn/rIiQXHqZdK4LnTQxYpG2N23E3s6p58/1hvIepb0lhlhmjxGJJIntkYq1tQuzkXdF2WTuKiH0dgdBbVvak3KNRMzp66cxNOMzHHhO8wvayZt4mnrQuEAH7++KGMjFkje1r3Rq5qojm7bt+NNyt6LV23zXPUCqrXQ0OI4U9tJXXN/E9X1bWJJO1Gt3VGRNfGi8lVXOd0I3n7Ma1swDMcnkxrGslpbheWRvlbAxkiNmY1dnOikc1GSomy82Od0L3gPFbdDMVt2IYTi6sqqygw64w3K2yVL2ulWojV7ke9yNRFVXSOVdkTnseHLOp9x7Ksiu2RLdb3ab5X1tBXxVdDURsWjqaSJ8McsSOjcm7o5Fa9H8SKiN5JsbSv1306teTvxuuymkhusdS2klRY5FhiqF6Inzo3rTH7qicLnou/LYsRzka1XOXZETdVUCnm9Tvamtyx6Zdly1mW2+Khvda6uhdNUtjc7heirDtG7ge+LZiNajHcmo72RJaDSHHbJllkyPGkqbDU2q1+hK01C5jKespGonW452Oaqu62qbscitcm6oqqnI8mI6+ac53kLLBiuUU9ddpGPkhgWCWLshrd+JYnPY1sqIiKvsFdyRV6EU1GI9UTi2V59k2Hs7Ipa2z1i00D3U07kq+CFZZXe5o2NG8LkRHO3dw7pvum4e+0aEY5ZqTFKalrbq+PGL3VXqiWSaNVfPULKr2ybRpuxOvv2ROFeSbqvPffUumtpo7/nF6iqK1arMoaeK4MdIzgjSGBYW9aTh3RVa5VXiV3PvJyIPiWs+K0OLXXMspz2Cus9yyOWhpZVpJoYKJyJtFSNa6NH8SMbxPe5Nle53NEREJRYtcMCya13y42TIGVENij67co3Uk8c9OzbdHOgcxJVRduSo1d+4BqJdALFFZcPo7Fer9YbpiVB6H2y80NRE2rWmVqI6KXijWORq8LV2VnJU3TbmSzT3Tq0abWiqoLJJWVc1dWSV1wr6+brtTW1Mm3HLK9ERFcuyJyRERETZENDjWrVph0ntOcZ3kVijo6piq+4UDJoqWZyyOaxsLJU66qqjduHZVVUXZNjYWjWbBb5jV3yOiyGCOzWZdrjUVcMtL2Mqoioj2Sta5FXdNuXPdNt9wJ2CFYZqviWo7q+nwm9xVldRxo+WnmppYJY2u9q9YpWserFX+0ibL3xpdnqahY3NWVNM2gu9tr6i1XejY/jbT1tO9WSta7utXk5q/kub3QJqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVll+t9kxDJajHnWfIb3caWninqUtVv6+2FsnFwI5yubzXhVeW5Zpzfeu3nnn+W2n6s5Y4iVeuNtf6E5z9Ct+8HrjbX+hOc/QrfvDUguEy23rjbX+hOc/QrfvB6421/oTnP0K37w1IGDLbeuNtf6E5z9Ct+8HrjbX+hOc/QrfvDUgYMtt6421/oTnP0K37weuNtf6E5z9Ct+8NSBgy23rjbX+hOc/QrfvB6421/oTnP0K37w1IGDLbeuNtf6E5z9Ct+8HrjbX+hOc/QrfvDUgYMtt6421/oTnP0K37weuNtf6E5z9Ct+8NSBgy23rjbX+hOc/QrfvB6421/oTnP0K37w1IGDLbeuNtf6E5z9Ct+8HrjbX+hOc/QrfvDUgYMtt6421/oTnP0K37wo/Gc6qLMl8bW4ZmG9bfbhXRcFp4vwU07pGb+y6eFybp3FLaBYjCID6qSfoZmf0N/+Y9VJP0MzP6G//MnwKID6qSfoZmf0N/8AmRTUzURLpgV+ovSrlVH1+m4Ov1dr63FH7JvN7uJdk+MukhOsHaxyfxNfrNA6vh9yj+SnkMzCH3KP5KeQzNbIAAAAAAAAAAAAACl8B/GK1g8Ssn2EhdBS+A/jFaweJWT7CQkqugAFQAAAAAAAAAAA/PseFJ1qEiYk6sRiycKcStRVVE36dt1Xl8Z+gAjl29+aTwp5SRJ0J4CO3b35pPCnlJEnQngPE9H+0doepHth13upR5PoAPbORxnR00lD1OXVMUtWipWx5RkK1HF0uc5sbmu/axzVT4ix8ugjp886mt0EbYljnrImK1qJwsW1v3aneTknL4kLkteIUVmym9362vkhkvbIVr6dNutyTRN4GzJ3UerOFju4qMZ0Ki7yEDhhmRWaw9TRlmlN5Y6p1Tq624UUtjfC51XW109W90VQxu3s2cDo5EkT2OzenkdjdduePYL110D7vebdaeJYWLu6qqI4d+FF77nJt+0kHC3iR3CnEibb7c9u8fQOD7fnXpuv2ieS3vUJ2QXr0x07rjaKS3RQUVgSeGSPrDnNj4438bmxbSSez2VUReHdLrwLLrLhuvmqmOZRcIbXd8hutvq7PBULwrXRuo2R7xflKj2OaqdxUOg0jaiKiNREVd15dK98KxqvR6tRXNRURduaAcPXG6UVjxqS53eZtNb6PqiaieolciqkcbaiVXOXbnsiJuW1i2R2jUzqlo8m06qG3WxWfE5rddrvTMVaeaeSoY+KnbJts9zUa567bom+2+67Fsag4BFnyYuk9c+h9AMhpL2zgjR/XnQK7aNd1TZF4unntt0EvaxrGo1jUa1O4ibAcN4U6Ky6TdTJl2SRzvwrH6qukvEscbpGUssjZWUtRI1qKqMZJvu7bZvEnf2Wz9bc2xvU3BLZdcLuLcox3GMvtNdkvodG+Zq0LJOKToT8IjUVr3I3fZGLvtty6XMWMbG1GsajWomyIibIgHO9myi1aodUpYb9pxVxXiyWPF6unvF3pN3QPfNLGsNKsm2znIrHScO67br0KbLqc6aRuRa11caK2gqM+rGwp3FkZHG2Vyf/AHcvC1e8Xo6NUieyBUicqLwuRu6Iq93bu8+ZpcNxGgwfH6azWnrj4onSSyzzKiy1E8j1fLNIqIiK973OcuyIm68kRNkA3wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABzfeu3nnn+W2n6s50gc33rt555/ltp+rOWOaS2gAM0AAAAAAAAAAAAAAAAAAAAAAAAAAAITrB2scn8TX6zSbEJ1g7WOT+Jr9ZoHV8PuUfyU8hmYQ+5R/JTyGZrZAAAAAAAAAAAAAAUvgP4xWsHiVk+wkLoKXwH8YrWDxKyfYSElV0AAqAAAAAAAAAAAAACOXb35pPCnlJEnQngI7dvfmk8KeUkSdCeA8T0f7R2h6ke2HXe6lHk+gA9s5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5vvXbzzz/LbT9Wc6QOb70i+rnnnL/9ttP1ZyxzSW0B92XvKNl7ymaPgPuy95RsveUD4D7sveUbL3lA+A+7L3lGy95QPgPuy95RsveUD4D7sveUbL3lA+A+7L3lGy95QPgPuy95RsveUD4D7sveUbL3lA+A+7L3lGy95QPgPuy95RsveUD4QnWDtY5P4mv1mk32XvKQnWBF9THKOX/6NfrNA6uh9yj+SnkMzCH3KP5KeQzNbIAAAAAAAAAAAAACl8B/GK1g8Ssn2EhdBS+A/jFaweJWT7CQkqugAFQAAAAAAAAAAAAARy7e/NJ4U8pIk6E8BHbt780nhTykiToTwHiej/aO0PUj2w673Uo8n0HxV2TdV2ROkoHUTqlaWjrqnHdJqSLLcjiXgqKvj2t9A7/6sqe3cn5DOffVOg9lcu0WaJruTiIcczERmVt5tnuO6d2SS8ZjdILXRM5NWRd3yu7jGMT2T3L3kRVIBovrfLq/kOX0zLFPY7dZUpOxEq+VTM2ZJHcb29DEVGNVG815817ic/Q43VXS9pkme3SXKcmX2lTUN2hpUX+xTw+1jb8fSfaW2ZTYcjvV5wnM6jHXXhIEq4WW+GdHdaarWLu/f8p3Rt0nko6UaOdRNHKiI5+M+TjjV25qx3O4wcY+j2q/wq1n0JSeaa66Z/qnjVRZKuo1GqblBPeaGkmp32mmjR8cszWuTiRu6clXoPpWdv7Pv3KbdFeZnhHCW2nUWqpxEu3wAffdAAAAAAAq7UrUO+2vJ8ewfTqjt1Xl18hmq+vXNZOxKCjh2R80jWbOequcjGtRU3Veaoic9bieomY2fUalwDVqlsz6+7UEtbY7vZWSxwVSQq1JYXxSK5zJGo5Hbo5Wqi9xQLjBRNJqDqRimqmH4pqEmKXely3sxIW2OKeKe39Yj65xv6693XI1TZFds1eJfAi3sAAAAAAAAAAAAAAAAAAAAAAAAAAPyqKmGjhdNVzR08LduKSR6Nam67Juq/GoH6gAAAAAKvyLqitMcTvdbZciy6koLpQv63U074pVdG7ZF2VUYqdCoaz11ejv6c0P+xN5hMwuJXA+aON8bJJGMfI7hja5yIrl2Vdk767Iq/sMzirqotbsI1CxLG7dp7lrau7wZBBUItF12GWFiRyJ1xrlamyork6F7p+ml3VZ3XFlgtOsLH3W1psyLIaWLeWJOhOyIm9Kf428++i9Jpqv26a4oqnjL6FrZ2qv6arU26M00zicdztEGvst8tuSWumulgr6e5W6pYj4aimlSRj0+JUNgb3zlSdUq56aS3CJkkkbKi422nl63IrFdG+thY9m6Ki7K1VRfiVSqHaP4VxO/wDA2dP/AKqbzy1uqV7VVR/nFp/n4DQv9u7wmUJKDepBhX5jb86m88epBhX5jb86m88m4MkQj1IMK/MbfnU3nj1IMK/MbfnU3nk3AEI9SDCvzG351N549SDCvzG351N55NwBCPUgwr8xt+dTeePUgwr8xt+dTeeTcAQj1IMK/MbfnU3nn4P0VwOSR0jsej645ERXJUzIqonRuvHzJ8AID6ieB/mBvzufzx6ieB/mBvzufzyfACA+ongf5gb87n88eongf5gb87n88nwAgPqJ4H+YG/O5/PHqJ4H+YG/O5/PJ8AID6ieB/mBvzufzx6ieB/mBvzufzyfACA+ongf5gb87n88eongf5gb87n88nwAgPqJ4H+YG/O5/PHqJ4H+YG/O5/PJ8AID6ieB/mBvzufzx6ieB/mBvzufzyfACA+ongf5gb87n88eongf5gb87n88nwAgPqJ4H+YG/O5/PHqJ4H+YG/O5/PJ8AID6ieB/mBvzufzx6ieB/mBvzufzyfACA+ongf5gb87n88eongf5gb87n88nwAgPqJ4H+YG/O5/PIpqXpPh1lwK/XG12ZtPWUtN1yGRKmZ3C5HN57K9UX9pdJCdYO1jk/ia/WaB1fD7lH8lPIZmEPuUfyU8hma2QAAK319ye64Zo9ll9xqq7CutDSJJTT9ba/gd1xqb8LkVF5KvShUlPb9VZ6eKVdYK1vXGNdt6X6Plum/wCSWL1UnaAzrxFv2rDV0H/IUn6hn1UIqJehWqvww1v8P0fmj0K1V+GGt/h+j80moBlCvQrVX4Ya3+H6PzR6Faq/DDW/w/R+aTUAyhXoVqr8MNb/AA/R+aPQrVX4Ya3+H6PzSagGUK9CtVfhhrf4fo/+xpqDAM+tmQ3fIKHVasiu94ZCyun9A6VeutharY04VTZNkcvQib78yzgMGUK9CtVfhhrf4fo/NHoVqr8MNb/D9H5pNQDKFehWqvww1v8AD9H5o9CtVfhhrf4fo/NJqAZQr0K1V+GGt/h+j80ehWqvww1v8P0fmk1AMoV6Faq/DDW/w/R+aSPQnJMvqs/zzGs1yeTJ4rRTW+WlmkooaZWrM2Rzk2jRN+hOlV6DZGk0V7eOqviFn+zlA6FABUAABHLt780nhTykiToTwEdu3vzSeFPKSJOhPAeJ6P8AaO0PUj2w673Uo8mtyGwUGU2Svs16idPb66F0NRG2R0auYvSiOaqKn7FOS8j0UyrROCSTCqeXMsGjc560UcbUuVA1V3VWoiIlQ1P+rynY4PV6rSWdbbm1epzDhroprjFTimw5FbMmoUrLJVsqod+F6JyfG7ute1ebXJ3lNdd9QcXsFfJQXm90tFWRoivikVeJqKm6dzvKdAandTvZ8yrpchxKqdiGZbKvohSRosVUv5NRF7WRF7/J3xr0ES6nfT7KLDmmo0mp1gpIKmpS3JTVETUmpqlGMla58TlTdO4qtXZU3TfuHh46JUxqJia/+PHDxy4I0Ub3Pgp/1WcJ/SSh/e7/ALGhyfP8ZyF+OUNkvVLW1jsjtj0ijVd1RKlm680OrMstNvZqtjzG0FIjFjZu1IG7L7J/xFrsslsY5rmW6ja5q7oqU7UVF/cbtm7D0saqqumqc26vlx7/AAZWtPRFczHdL3gA96+gAAAAAOf9WLgzTLW7DtS75HMmJy2Wqx+7VscTpG25XysmhlkRqKqMc9qsV3c5b9KGutuY2fWzX/Gr9g1Ql1xfT213B1bdomuSF9XWMYxsDN03erY43OVU3Tmnd2OkVTfkvNCt8l0NxHI8gXIY47lYL65jI5q6xXOa3yTsZ7VsqRORsm3Ru5FXblvsBSVXm+GZTr/guRaGV0l1yq8TrTZY2njm4PQpsW29S2RNoXscxnCmzXKqbL3N+tTFrGtVytaiK5d3KidKmQAAAAAAAAAAAAAAAAAAAAABzJfc6uNs6r2jVr9sXp7XRY1cFV3KOtreyKqB23xrTxs37nXE/KIrp1rrLi9TrdmuVxvqLVWRw5JYadj9nVFH12aghTfbZvH2LBz58nopY+R6DXbKcb1hp7lXUcN8y+7x19mqoJX/APCpTRQto1e7hRWvR8K8XDvsjuSqefPupoTJ0tVpslbT27H4sLlxipc7i68zrckE1HKxiJwv4JYVVyK5q7LyVd12DaW7U3P8VybD6LV22Y5Ba8ue+npprQ+dsluqkiWVsM/XVVJEc1rm8beHZydG3MqPWXUHO9TtAMlyqktdgt+ndwnpkoI5pJluctO2uia2oXb8GnG5qKke26NXfiVU52y3TbP8+yzD7hq7LjcFqxR0tQyCyzzzOuVW+JYklkSRjEiY1HOVGor13VU32IVcdDdVm6R1ukltrcQrMYhfGy23asqamKs7FZUtmbFJE2JzONOHh40dtsict1VUCe646mZXp1UR1Fju+ndptnYnXWR5PcZYamumRXcUULWq1ERGo32S8XN2yoiJuWHprmsOo+A47ldLTupI7xQx1KwOdxLE5yeyZv3dnbpvy326EK1yXS3MWat37MMWixe6RX2001vZNfHzdes/W+NHLAxjHJIx/HxK3ijVXJtxInMmmiOFXTTjS/HsUyCWjqK2zxPpuvUb3OjljSRysf7JqKiq1U3Tnsu6IqpzAsAAAfzZ1Wai626k7oi/+LM6U/8AoRkZ4G/kp/0nSOoXUpZnk+oeT5JYslsVJR3msSoZBVU0r3s2ja3ZVby/ske9Z3qN+luMfMp/+55rVbPv3b1VdPKX7DsXpVs3Q7Pt6e7nepjjw+akOBqc0aiL4D6qboqKm6L0oTPVTRPMNH7TarvkN8slzo625R0Kx0lPKx7Vc1zuLdy7bbMX95HsKxDJ9Urq626d25KxsT+CqulRuyipPlP29m7/AAt3U+dVoL9NcUYzMvV2ek+y7umq1G/imJxx5zPyjvebFtQb/o3cPRTBbolGyokTr9mmR0tLXO7yRJza9ehHM2U/ovpzk90zLELdechxyrxW4VLOKS31bmuez4+XNEXpRHIju+iFf6QdTZjOmEkV2r3LkuWq32d1rGJ+BXupBH0Rp8abu+PuF1Hq9LauWbe7XVmX4ftnXabX6qbuntblP5/PwVH1SvaqqP8AOLT/AD8BoX+3d4TfdUr2qqj/ADi0/wA/AaF/t3eE7YfCliADJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhOsHaxyfxNfrNJsQnWDtY5P4mv1mgdXw+5R/JTyGZhD7lH8lPIZmtkAACoeqk7QGdeIt+1Yaug/wCQpP1DPqobTqpO0BnXiLftWGtoGO7ApPYr7gzuf4UJ3r3P2BlwO/JX9w4Hfkr+4qMQZcDvyV/cOB35K/uAxBlwO/JX9w4Hfkr+4DEGXA78lf3Dgd+Sv7gMQZcDvyV/cOB35K/uAxBlwO/JX9w4Hfkr+4DEGXA78lf3Dgd+Sv7gMTSaK9vHVXxCz/Zym94Hfkr+40WiyKmuOqu6bL2BZ/s5SSroUAFQAAEcu3vzSeFPKSJOhPAR27e/NJ4U8pIk6E8B4no/2jtD1I9sOu91KPJ9AB7ZyAAAqXLu21jv6tn1nltIVLl3bax39Wz6zy2kPg7L/n6n+v8ASGi11qvMAB95vAavIMitOKWipu2SXGmtVtpm8UtRUyIxjU8K9K95E5r3DlnNuqDybUfrlv0rZNi+NOVWyZBVRbVdS3u9jRL7RF/Ldz7yIbLduq7Vu0xmXPqNTa0tv7S7ViFzandULhGlFXT2+/1s1dd53salutzGzTxtc5ER70VzWsbuqe2VFXuIpah/O27afwelmtt+P8DLlVTRTy1ta90sk8jJGvV0r+bnKvD/AO5afq56zfkYR82qvPOu5ob1ExERl8XT7f0V6Jmurd48M+Hi6/ByB6ues35GEfNqrzy3Op61NyLUuz5LJmUNtir7PeH0CLbo3sjc1sbHb7Pcq77vU5rli5ajNcYfU0+v02rqmmzXmYXGADS7g8kF1oKqlmq6WtppqWB8scs0czXMjfE5WSNc5F2RWOa5rkXoVqouyop+lbWQ26iqayrekdPTxOllcv8AZa1FVV/chwjp5l2Q2/RzKcNuNQrch1DfR3HHld0rFepXRTbfqlbLIq/40UDvClqoK6mhqqKaOppp42yRSxPR7JGOTdHNcnJUVFRUVD9Tj6g1ou+I6KaT4za670LyC4y1ViqbmtqluTqCK2q6KaRtLEiukkXrcaImyp7JVdyTc9FL1QuW4ha80gq6ipzttJS0b8evNfjc9l67V1FQlOlNPG9jGu4HPZJxMRN28Xd9qHU9bkNrt13tdorq6Cnud1672BTPds+o601HScKd3haqKp+tuvFuvCVS2mvpa9KSofS1C007ZOszsXZ8b+FV4Xt35tXmndOarljmbWXXjRdmcZrFk9TUQX1Y3x2iKkSll7DbxcHAvs2c27I5N/Y81Xfl68Iy6627SLUesvuZWrGrjZ8yuNvkyN9kha1yRVDI1ldTR8LZJpE3ROlVc5PbbbAdLg48tmvOY0OOat0T8hqb/V4/jbL3Yr1X4060zqjuNqtfTPY1r2o5rVa9G7Kir4EsC25RqHi+o+m8eWZTRZBZM7jqY5rfDaWUrbbOymWoYsMiOV72+xVi9cVV7vd2QOgwci5trdkOG5s+ss+oiZbbaXJIaC52OnxNzaKkp5Z0j62txaiok7Ecm/E/ZXIqcKe1XroAAAAAAAAAAAAAAAAAAAAAAg2p+lNi1ctdstWXdkPttFcGVzoIJOt9fc1j2oxzk5o32fPbZeXSSmx2K2Y1a6a14/QU1st1MxGQ09NGkbGJ8SJ5e6bAAAABUfVK9qqo/wA4tP8APwGhf7d3hLT1Bwik1DxWrx+5VVTRRTyQysqKVWpJFJFI2Rjm8SK1dnMauyoqKVyvU/3NV3XVLKt1/wD41B/TmUThJeAHv9b/AHP4Ucq+bUH9OPW/3P4Ucq+bUH9OMmHgB7/W/wBz+FHKvm1B/Tj1v9z+FHKvm1B/TjJh4Ae/1v8Ac/hRyr5tQf049b/c/hRyr5tQf04yYeAHv9b/AHP4Ucq+bUH9OPW/3P4Ucq+bUH9OMmHgB7/W/wBz+FHKvm1B/Tj1v9z+FHKvm1B/TjJh4Ae/1v8Ac/hRyr5tQf05W+e4HkWKZri9iotSMhlp7vR1080ktLRK9iwdZ4UbtCibL11d9+8hconIIJ6RMj+EnIPmlF9yPSJkfwk5B80ovuSidggnpEyP4Scg+aUX3I9ImR/CTkHzSi+5AnYIJ6RMj+EnIPmlF9yPSJkfwk5B80ovuQJ2CCekTI/hJyD5pRfcj0iZH8JOQfNKL7kCdggnpEyP4Scg+aUX3I9ImR/CTkHzSi+5AnYIJ6RMj+EnIPmlF9yPSJkfwk5B80ovuQJ2CCekTI/hJyD5pRfcj0iZH8JOQfNKL7kCdggnpEyP4Scg+aUX3I9ImR/CTkHzSi+5AnYIJ6RMj+EnIPmlF9yPSJkfwk5B80ovuQJ2CCekTI/hJyD5pRfcj0iZH8JOQfNKL7kCdkJ1g7WOT+Jr9Zp+XpEyP4Scg+aUX3JFNTMPvtDgN/qazPL1coIqbifSz01K1kqcTfYuVsSORPAqKB2/D7lH8lPIZmEPuUfyU8hma2QAAKh6qRdtAc5XvULftWFQxaE4nVwx1E0t965MxJH8N7qWpxKm67IjtkTn0FvdVJ2gM68Rb9qw1dB/yFJ+oZ9VCd69yt/UBxD+9v8A9O1Pnj1AcQ/vb/8ATtT55aAGIMyq/wBQHEP72/8A07U+ePUBxD+9v/07U+eWgBiDMqv9QHEP72//AE7U+ePUBxD+9v8A9O1PnloAYgzKr/UBxD+9v/07U+ePUBxD+9v/ANO1PnloAYgzKr/UBxD+9v8A9O1Pnj1AcQ/vb/8ATtT55aAGIMyq/wBQHEP72/8A07U+ePUBxD+9v/07U+eWgBiDMqv9QHEP72//AE7U+ePUBxD+9v8A9O1PnloAYgzKr/UBxD+9v/07U+eb3qb8bocS1a1QtdoWpdSRUdpe1ampfO/dzJVXd7lVV5kzNJor28dVfELP9nKDLoUAFQAAEcu3vzSeFPKSJOhPAR27e/NJ4U8pIk6E8B4no/2jtD1I9sOu91KPJ9AB7ZyAAAqXLu21jv6tn1nltIVLl3bax39Wz6zy2kPg7L/n6n+v9IaLXWq8wAH3m9zp1Qmg1/1Au9DlOMXRLtVWxu7Mbu0n/BSKic3RbcmSL33I5FXuoUna8kjq7hPZ7rR1NiyGk5VNqrmdbmj+Nvce3vOby2O9yDak6R4tqrbmU2U0KrVwc6O40zutVVI78qOROaeBd0Xuodmm1VWnnhxh8TaeybW0qYmqcVRyn/pyzNNFTxrJUSshjb0ve5Gon7VPJ6NWz85UXzln/c1GtGleeYJYKi23mmXMMZmqKdIr1TRbSwsSZiq2qiTo5IqcbeXf23OtPW7aU/B/j/zFp9K5tOImNyMvL6fovXXE/bV4mJ7uOY8XMXo1bPzlRfOWf9y2upBlZNa9RZIXtkjdlUqtc1d0VOsRdClh+t20p/QDH/mLSXYnhGO4LRTUWHWaislJNL16SGkiSNrn7InEqJ3dkRP2HBqdZOppimYxh6LZmxqdm3Kq4rzmMcm/ABwPQtBnGPT5dhmQY/SV/oXNdrdUUTKzrPXVgWWNzONGcTeJU4t9t0IY3Q6xpkGmN5c/iqMBt0lBRp1pESZroGxNV3Plw8KuROeyuUtIAUZWdTrJ1usqrHlk9nyCHLK3JLFcoqBr/Q51WxGz0z43PVs0bt3qvtPbJ0bc97dtJ73nOA3/ABfVHLm3p90WJ9NU2y1tt/YEkbkex8acb3OckjWu3c7nttsiKWsVvWa04/brZnt6r0lix7DJuxKuvTZUqKtrUWWGJvdVrnxx7783uVvLh3UNBaNIcymzvDMqz3UClyKTFWVkdPT0+Pto+v8AZEPWle9yTO2dyRV2Th5bIidJ5bl1O61mJXu0U+SdYuFXm82YUFY63o+OmqHT9eZFJCr9pmJzRebeLp2TbY/Gs13y3E6Wiv2pumkmM4ZVTRRy3KO9R1U9vSVyNjfUwIxvA3ic1HK1zuHfnuptdSdWc0wL0du1Lp0lyw+wxJPV3OS+xQTTxIxHyPggRjuJGIq+3cxXKioid0DRXrqeL/lFVl1fk2exVlwynGX2GrWOxtihp2pJxxPhYk3EiN4n7te5yuV+/E1ERCfXrTH0Xvum909FOs+kuaWTrXY3F2Xx0roNt+JOt7cXF0O6NvjPXdNTLbaY8LramCdLNlc8VLTVq8kgnmj46dkjOlEk5s37j1Yi+23SbAc4VHUx352G1mE0OoLKPE23N1zt0CWFj6hk3ZPZDGzzLL+GY2Tn7Fsbl2T2WybL0bGj0Y3rqtV+ycStTZFXu7IZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQ2s3ba08/yu7+WmL5KG1m7bWnn+V3fy0xY5pLAAGaAAAAAAAAAAAAAAAAAAAAAAAABCdYO1jk/ia/WaTYhOsHaxyfxNfrNA6vh9yj+SnkMzCH3KP5KeQzNbIAAFQ9VJ2gM68Rb9qw1dB/yFJ+oZ9VDadVJ2gM68Rb9qw1dB/wAhSfqGfVQnevc9AAKgAAAAAAAAAAAAAAAAaTRXt46q+IWf7OU3ZpNFe3jqr4hZ/s5SSroUAFQAAEcu3vzSeFPKSJOhPAR27e/NJ4U8pIk6E8B4no/2jtD1I9sOu91KPJ9AB7ZyAAAqXLu21jv6tn1nls9wqbLe21jv6tn1nltIfB2X/P1P9f6Q0WutV5gAPvN4CM3/ACK42+80Vrs9tp6+eopZqlzp6xadrWRuY1U3Rjt1XjTvdB5rXnkFxZZJX0jqaC5UNTVvfJIi9ZSFWIqck9ki8aqi7pyROXPlom/biqaZnj+/8sN+nOEuVEcio5EVFTZUXun0jlivt2vbqer9B4qWz1LOuQzSVm86sVN2uWJGbJvy5ce6d0kZsoriuMwyiYmMwAAzUAAAAADh+3Wa6XjqL8rkpqeWuvNLktXdLjTJzdM6nuiSzNVOlV63Gq7dO6IdwEcxTCrbhst/dZXTthvV1lus8EjkVkU8rWpJ1vZEVGuc1Xqiqvsnu22RURApLqhdTcWzbQiutmG3aiyC7ZnDBQ2S30kzZJ6iWWRm34NF4m8Cbq7dE4eHZefI/HWrIbbk2QY5oi++UtDQSQQ12X11TVNhVlviVqspkcqp+Enejd0Rd0ZuuyopYORdTvgd5r6W7WO2NwrI6Sp7JgvWNxRUVW16oqORXcCse1zVVHI9rkVFU99Pobg87XzZdj1nzS8SuV1ReL5Y6CWsqF6E43xwMauyIjUXh32RN9wIF1WM1PU9T/PU41NDK+O52p1qfSPRzFkSthazgVvLo3227x0GRC8aaY9d7djlrSjZbrPj9yhuNJbqCNkFOskPEsbXMRu3A17kfwt4fZMbvum6LLwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUNrN22tPP8AK7v5aYvkobWbttaef5Xd/LTFjmksAAZoAAAAAAAAAAAAAAAAAAAAAAAAEJ1g7WOT+Jr9ZpNiE6wdrHJ/E1+s0Dq+H3KP5KeQzMIfco/kp5DM1sgAAVD1UnaAzrxFv2rDV0H/ACFJ+oZ9VDadVJ2gM68Rb9qw1dB/yFJ+oZ9VCd69z0AAqAAAAAD8auspqCB09dUQ0sDVRFkmkRjUVV2TdV5c1VE/aRe1ahW6437J7VUM9DW4/PBDJV1M7GxTulZxt4F3723T07myzCwUGS45X2+8Wll8pnRq9KF8nAkz282N4t02XdE59w5twvQCvob/AI9cctxmK7Wy7rI+vtrqx6JZXIu8K7q/8IiM2aqLuu/JCcVjDq4BE2REToTkCoAAAAABpNFe3jqr4hZ/s5Tdmk0V7eOqviFn+zlJKuhQAVAAARy7e/NJ4U8pIk6E8BHbt780nhTykiToTwHiej/aO0PUj2w673Uo8n0A8lzulFZbfUXC8VcFBQ0zFfNUVEiRsjandVy8kQ9s5HrPOytppauakiqIn1UDWvlha9Fexrt+FXN6UReFdt+nZe8cw5n1RV7zp81r0Vi7AtO6xz5VXQrwuToXsWF3N6/43cvi7pBtEdR8Y0WzrUSHPL1dZZbn6HyRVlTTz1ktU9sciyOc9jXc93py+PZOg4I1+nq1H3emrNURmfkwiumat3PF0Ll3bax39Wz6zy2kOTsh6o/Tuv1Cs12pbrWPoKZjUlk9CalOFUVy9Cx791Cx6LqrtK6+upKKnvtV2RVzx08KPtNUxHSPcjWpusaIm6qnScOzqZovaiauGauHz4Q124mKqvNdQAPut6EZbhUWXZBRpc6VJrY22VULpeJEWKZ7ouBUTfffZHLvtty5nlp8eu9ymssd6o2U7Ka2V9vqpYXM4F4+tNY9jUXkjmsVdtuXQu3LewQcs6a3NU1ePP5/v9Za5t0zOURxeov9DTW2z3SxuTsSNIJq9tVH1l7GN2a9rd+NVdsnsVam268+/LgDdbo3Kd3OWVMbsYAAbGQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABSOtlgyOfMcNyHGsdq8kprdS19NVQUc8McrFm6yrHbSvYit/Bu32XfoLuAHMnZ2cfBVkvzug/qB2bnHwVZL87oP6g6bBcymHMnZ2cfBVkvzug/qB2bnHwVZL87oP6g6bAzJhzJ2dnHwVZL87oP6gdm5x8FWS/O6D+oOmwMyYcydnZx8FWS/O6D+oHZucfBVkvzug/qDpsDMmHMnZ2cfBVkvzug/qB2bnHwVZL87oP6g6bAzJhx7bNULleKVaq26fZHUU6SyQ8aTUaezje5j05zdxzXJ+w9np8v3wcZJ/v0f3x++lv8A5Td/m1z/AJ6YmZmiC+ny/fBxkn+/R/fD0+X74OMk/wB+j++J0AIL6fL98HGSf79H98PT5fvg4yT/AH6P74nQAgvp8v3wcZJ/v0f3w9Pl++DjJP8Afo/vidACC+ny/fBxkn+/R/fD0+X74OMk/wB+j++J0AIL6fL98HGSf79H98RTU3MbxX4Df6WqwW+22GWm4X1VRNSrHEnE32TkbKrtvAiqXKQnWDtY5P4mv1mgdXw+5R/JTyGZhD7lH8lPIZmtkAACvdc8Rumd6TZTjuOxxS3S4UqR07JZEjarke1ebl6OSKVHBb9bIIIok0+sDutsazf0xpz2Tb8g6eBFcy9h62fB7j/8Rp5g7D1s+D3H/wCI08w6aBRzL2HrZ8HuP/xGnmDsPWz4Pcf/AIjTzDpoAcy9h62fB7j/APEaeYOw9bPg9x/+I08w6aAHMvYetnwe4/8AxGnmEco8i1XvmRZFitDgdmbdrNBA6tT0wcKMSdjljVruDmuyL4Dr0pfAfxitYPErJ9hIQce4RrDqRa7TTzTV9FksScTJKa5M4JWq1ytVEmZzXo/tIpI06qS/xVzKW54dQWpr12Soq7lI2BF+N7Y1RP2kIgpPQ265LblTbsG/V8CJ3kSd23/sp6VRHIrXIitXpReaHZFmmqmJh6ijZlm/ZprpnEzDoew3rVPKaJtbjWJ4jeKN2ypNR5WyZv72sXZfiNp2HrZ8HuP/AMRp5hSnU2aTQ6iZ1cb5DdpMVpceqGsqKG11L6etrHLza6RWKiNhXZeabq7ZU3TpP6CImyIib8u+pyTGJw85doi3XNMTnDmbsPWz4Pcf/iNPMHYetnwe4/8AxGnmHTQDU5l7D1s+D3H/AOI08wkuh+FZpZ84zfJc/tFDZlvVPQRU8FJXpVJ+AbI1yquybe2QvUEMgAKgAAI5dvfmk8KeUkSdCeAjt29+aTwp5SRJ0J4DxPR/tHaHqR7Ydd7qUeTW5FXXC22OvrLHbFvVxghc+noUnbCs706GcbuTd++pwvPkd11jyGpbq3WyQXG2zKrcNdG6mgolReTnxu5zr/jXdO9yO+yv9TNHMX1UpYkv9M+mutMm9FdqN3Wquld3FbInSn+Fd0XvHptfprmqsTbt3Jome+HBcpmunEThz4xjY2NZG1GMaiI1rU2RE7yIZI5U6FVP2moyuy5ho5Lw59Ct+xdHcMOTUEC/g07iVUKbrGv+NN2nmwawZTq9lWVUuG5fa7RarMyidE99tSs6+k8bnbo5Ht6FYvf6fiPyqOj2unUTYmOPPPdP4vkfdbk1bqQcTu+v7yJaguVaPHt1Vf8A4ltf8ywsz1uOpPwk2b+HP/8AqfjL1L+cXOrtfo9qDa6uho7jTVr4YrCsTnrDI16Ijkl5b7bH2dB0b1um1Vu7XMYpmJ5t9vS10VxVPc6oAB+mPqAAAAACE6maj02nNpoZkt897vN2rWW+z2qme1klZVPRVRvE7kxqIiuc9eTUTfnyRYpZdYr/AG/MbNjGq+FtxCe/q9lnrqW7MuFLUTMarlge5GMWOTh6N0VHbLsvcNN1QlUzF8y0gzi7L1vHbDf5oLpMvtKZtXTuhjmf3mNeqbu7nEnfPHq/kNpz/UHSDFMRuFPeLnR5RDkVYtBM2ZKWipopN3yOaqoxr3Ssam/tu4BNPV0sVVqza9PLNTVdfW1PZjauu606Omp5KdiOfE17m7SyIrmo5Grs3iTdd+RaRR2etRvVM6No1EanoXf12RO6scCqXiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAByhpb/AOU3f5tc/wCemJmQzS3/AMpu/wA2uf8APTEzNkMQAAAAAAAAAACE6wdrHJ/E1+s0mxCdYO1jk/ia/WaB1fD7lH8lPIZmEPuUfyU8hma2QAAAAAAAAAAAAAFL4D+MVrB4lZPsJC6Cl8B/GK1g8Ssn2EhJVx3qHKto1h1CtNJSVFwuVTkcslHQUkayTTulY2TZrU591eZrbdcIbpSMqafdGu3RzHJs5jk5Oa5O4qLyVD+iNn01xmyZje8vorbGuRXlzOyq2T2T0a1jWIxm/tG7MRVROlenflty/wBU5o+/DLrU6j4lSudZa16LkdFE33CReSVjETuL0PT/AO7urt027s04ieT72i2lNE026+ryU7ZMivGn+U0WYYh7K50ScFTSq7ZlfSqu74XfH3Wr3FRD+hWA51Z9SMUt2SYzP16hrWb8K8nxPTk6N6dxzV3RU/8A82P53RvbKxskTkex6I5rmruip3FQsrqWL3kdDqnW2/CqOW6YnWorsh58NPRTonsJWPXl1xehzE5qnPucsr9EdaG7a2loiPtqef5u7AAcrzQAAAAAAACOXb35pPCnlJEnQngI7dvfmk8KeUkSdCeA8T0f7R2h6ke2HXe6lHk+gA9s5GEsUc8ckU7GyRParXsem6ORU5oqd1CE4PpLi2nF5yC54Zb0tXo6sLqulidtA18fHs5jP7G/XF3ROXRsiE5AAAAAAAAAAAAeeuoaW50c9FcqaGso6hixzQTxpJHIxU2VrmryVF7ylS3HqdMdobuy96W1tTpfekhWCabHqeBkFTGruJEmp3sdG/ZeaLsi89t9ttriAGnpcdpOOz1l4iprtfLXTLBFdZ6SNKhFc1qSuaqJ+D65wormt2ReSbbIhuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOUNLf/Kbv82uf89MTMqjDc/x3FLVV2jI7j6G3Omu1x69TTU8qPZxVkzk39j3WuRf2kg9WDCPz/D/ALEvmGbFNwQj1YMI/P8AD/sS+YPVgwj8/wAP+xL5hRNwQaTWTBYWK+bI6eNidLnwyoiftVp+fq1YB+k9J/tyeaBPQQL1asA/Sek/25PNHq1YB+k9J/tyeaBPQQL1asA/Sek/25PNHq1YB+k9J/tyeaBPSE6wdrHJ/E1+s0/D1asA/Sek/wBuTzSKamar4ZesCv1vtWQU1VW1NN1uGJrJEV7lc3ZE3bsB3DD7lH8lPIZmEPuUfyU8hma2QAAAAAAAAAAAAAFL4D+MVrB4lZPsJC6Cl8B/GK1g8Ssn2EhJVdB+NVSwV1NNTVkTKinnY6OWKRqOa9ipsrVRelFRdj9gVHHMvUb3N2d1dto72lv0ze7smNInb1rWuVeKjYq+1ai9D13XhVE5rudV4niNkwaxUtjxS3QWu2Urdo4YW7c+65y9LnL3XLuqm7BZmZ5tldyu5iKpzgABGsAAAAAAABHLt780nhTykiToTwEdu3vzSeFPKSJOhPAeJ6P9o7Q9SPbDrvdSjyfQAe2cgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACp+qU7TOQfrqL+chI6/27vCSLqlO0zkH66i/nISOv9u7wmUJLEAGSAAAEJ1g7WOUeJr9ZpNiE6wdrHJ/E1+s0Dq+H3KP5KeQzMIfco/kp5DM1sgAAAAAAAAAAAAAKXwH8YrWDxKyfYSF0FL4D+MVrB4lZPsJCSq6AAVAAxkkZDG+SVyNYxquc5ehETpUDIFd27V213DH8NuzadzEyaubRRwq/wBlA9eJHbrtzRHtRvc9shvp9Qsapr8lknujGXFZmwK3rT1jbK5N2xrLw8CPXdNmq5FXdORumzcicTT4/ThLfVp71M4mme/6TifqkwILkGqNotV1o7Tb5W11xlu1Nbp2NZJwROleiOTriN4ONqLvwb799EP3h1LszaC5XC4TdYo6S6OtrHRQzzSSSIxrtljSNHo7mvJEcmyIu/Pk+xuYicc1+73cRO7PFMweCzXmgyG2U9ys1SysoahquilZvs7ZVReS80VFRUVF5oqKinvNUxMTiWiYmmcSAAiI5dvfmk8KeUkSdCeAjt29+aTwp5SRJ0J4DxPR/tHaHqR7Ydd7qUeT6AD2zkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVP1SnaZyD9dRfzkJHX+3d4SRdUp2mcg/XUX85CR1/t3eEyhJYgAyQAAAhOsHaxyfxNfrNJsQnWDtY5P4mv1mgdXw+5R/JTyGZhD7lH8lPIZmtkAAAAAAAAAAAAABS+A/jFaweJWT7CQugpfAfxitYPErJ9hISVXQACoGgzinuNZht+pbBD2RdKigmhpWcbWbyPYrWru5URNlXfmvcPbT5DaKy5z2ykutDPcoN1mpI6pjpo9uniYi7p+1DWXTPcetlDVVKXahq308aSLBBXQdccirsm3E9qc15JuqJvyNlFNcVRiPBuopuRXExTmeHdKubtpVdKSa/vsrG1NPS0dNPYKbjazhq0fC+VN1VEbu6jhVFXZN5Hc+kW7T2sivNztt+tF5uNurb5JcWVlPeUjpEY+brzVkh64juNjtk5MVF4UXcsuPOMdlvVwsyXmibcrexH1MD5mtcxOFXKvPp2am7tva93Y/R2aY2xJlfkNpakErYZt6+JOtyO34WO9lycuy7IvNdjq+3v4xMfSf3/AJdv3nU4xNPh3T+E/r81ZUuL5NR0lHjzrBJPDSZYy6LdmVUPW56d1Wsznuar0k40R2ypw/2eSry391djmUUqXbsKnr0oa7KZauqitlZFDVT0a0zGtWORz2oz8K1vEnE12yLt8c7yfKqTG4KF0s9C2atqY4Ym1ddHTNVqqnG9HO6eFu67Iiqq7Jy33TN+Z2CPIlx2W7Ukd5SFs3YrpUa5Wu32236V2aq8Kc9tl22VN321yfi3fz/GU+3vVfFFHjPKfHjP9/7NLpVZLhjuM1Fvu9FJQyNudZNCySqSoVYpZnSMVXoqqq7P2VV5qqKvd3Wbkfo8zs1VZX3mevpaK1tnkhbVVFXCkT+B6t4kkR6t2Xh3Tnvt0oi8j0T5ZYKVtE6pvlshbXJvSLJWxtSf5G6+y/Zuc9cV11zVMcZct2Lly5NU08ZnwluAAaXOjl29+aTwp5SRJ0J4CO3b35pPCnlJEnQngPE9H+0doepHth13upR5PoAPbOQAAAGsut/obK+njr3ypJUI5Y2RU8kqqjduJdmNXbbdD1W+4U10o4qugmSenlRVY9N+ey7L080VFRU2NNN+1Vcm1FUb0c4zx/t+MM5oqinemOD0gA3MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFT9Up2mcg/XUX85CR1/t3eEtzNMQt2eYxcMevvX0oK5rUkdBJ1uRitcj2ua7uKjmoqdPQVx63S3Kq75xnSr/AJwz7osThGoBt/W5239OM6+mGfdFH41hNbeUvjqrOcvb2FfLhQRJHcWJ+ChndGzfePmuzU3XvmUTlFsggXqYzfp3mf0lH92PUxm/TvM/pKP7sonpCdYO1jk/ia/Wafh6mM36d5n9JR/dkT1M0/ltmBX6sdmGVVyQU3H2PVV7HxSeyb7F7UjRVT9qAdxQ+5R/JTyGZhD7lH8lPIZmtkAAAAAAAAAAAAABS+A/jFaweJWT7CQugpfAfxitYPErJ9hISVXQACooWKku1Rn1iulXbrhT1dLkdU2pp6Wx9apqeneyaJsq1KR8UyybxOc5Hq1OJVVG7IeuLEJabQK40MFklZeKiKoe+BKReyJJFqHKiq3biVdttvi225F3g7J1VU4xHLH0fQq1tU7uIxiY+nFUWQUctHkGocDrTWzS32zN9Dp6egkmY97aaVr2LIxqox2+3JypxcTdt1U/Ghwin9HLX17Ho0p24Q6lkVaHZrZuKP8ABqu3J+3Fy6ekuMGMaiqIxH74Y/RhGrqinER9Z8Ij9HN0GPXSFLRNlUF8bTVmI26jZ2NY0uD2SMjd16CRjo3uicquRd9movdXdvKe2izMxDOrSyakuNdQyY5R2ylrlonzu69DLJv15zGqkaqx7V4nbJyXnyLUBlXqqq+Ex4s69bVcjExw4/vl/wCqHoLRVWOux65XmxV9VZaC8X7rlPDQPmdA+aqcsE/WWtVzmcCPRHI1dkeipyU/bUimqcjhdQ0FlrqG1VNhlbRpT48ks81Q9z07He58bkp2psx268Crxbo5FaXkB96neirHGPmRrZ34r3eMfOf3n5tRisk02MWWSqZNFUOoIFlZOxWSNfwJujmrzR2++6L3TbgHJM5mZcNU71Uyjl29+aTwp5SRJ0J4CO3b35pPCnlJEnQngPEdH+0doepHth03upR5PoAPbOQBi17XpuxyORFVN0Xfmi7Kn7zGOeKV8scUrHvicjZGtciqxVRFRFTuLsqL+0m9HDjzXEonldNWVeQWOK11q0FWtNWdbmSNr9l2j5KjkVNiNTPt1TaLRbZ4aWmdG2oSeW4vc7rVQjk64xEa5vFI5zuJOfRzROZaoPh6jZUXrldze6/OJjMY+Hhz4dXjMRmYx4ZdlGq3KYpxy/7/AMqytFNDkTaD0V4qlUx6NzuJ68pWvc1XLz9siovPpRdzVXWZlwpbcy7SU8s9dY6XseoqahIm0j1345F4l9lxbpvw7r7HZdkVC26urgoaaapqXpHDC1XPdtvsifEnNV+JDX3OxRXl3FNWV0MMkXW5YIplYyRi77orduS89t02U+ff2PVNmbdFUVVYjOeGY5ZnOfCYjnMZmY4w30auN/emMR+X7/8AUIyRaTszIfRF7kuzGRJZEa5Ud7mnD1lE6V65xb7ft5Flw8fWY+vbJJwpx7dG+3M/OB9Ox3YtO+Pjp2NRYmuRVY1U9junSm+y7eA/c+zo9H93uV3N6J3vDzmeM54zGd3PDhEQ5Lt3fpinHL/H7nzADFr2uc5rXIqtXZyIvQu2/P8AefUczIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOWME9plX+q7x/NyHU5yxgntMq/wBV3j+bkMoSUrABkgQnWDtY5P4mv1mk2ITrB2scn8TX6zQOr4fco/kp5DMwh9yj+SnkMzWyAAAAAAAAAAAAAApfAfxitYPErJ9hIXQUvgP4xWsHiVk+wkJKroABUAAAAAAAAAAAAAEcu3vzSeFPKSJOhPAR27e/NJ4U8pIk6E8B4no/2jtD1I9sOu91KPJ9NffZpqeyXKak37IjpZXxbflIxVT/ANzYGL2Ne1zHojmuTZUXoVD2Vyma7dVMTiZiYz5xLmpnFUTKAVCy22gsFX2TP6EQUMPXo6Wo63I1zlbtKrf/AJjV32VPjVeaiokqW19dSxV1XEyTIIolc2ZeJI307XOair0Juq7d7lt0ISulx23wQUUc9NDWPom8FPLNE1z42IvsURypvyTZN/i3PctBSuesi00CvWVJlcsabrIibI/f8pETbfp2PgRsy9VHGrHLhmeHw0xMZzHDhwiP78Zd06miJ5Z5+HjMx+bUYu+Zq3ejmnlqW0VesMT5nq9/Ascb0RXLzXZXqm6kcmuVU3JKaro5qplHJdloZEnrd2yKiOa5rINtkRHJydvv8Wyk+igihdK6GJkbpX8citaiK92yJuvfXZETf4kPI6y219S6pdb6R1S9zXOlWBvGqoqKiq7bfdFRF/YdN7Q3q7Nu3RXjdnPf45j58I4cef56qL1EV1VTHOPl4IEtL2FieTT0tZWx1MNfUqipVP3arZlVF236VRUVV7u/M9F8qJ4Vyq4NutZTT22dnYcTZ162rusRuRix9Dkc5V5eHbuk2fZ7dJNUTSUFK+WoZwTPdA1XSN7zl25pyTp7x4oMYoGXatuVTT09VU1E7ZY3yQNV0O0bWbNcu6/2N+50nBc2Vfimmi3MY4xzqjHXxVz5/FHDlmPBvp1NEzNVUfl8uH0+qM3a4VdBXXxIqqanZNJb2SSufxdislc5r3N35N5fuXme64wJTV1otVPda1tFWTyrPKtY50nE2NFbGkiru1F9ttvvy5dJLH0VNIs6yU8L1qGoybijReuNTfZHd9Oa9PfPKlgtLaN1GlsokpHO4lg7HZwKvf4dtt/jOqdnXs1YqiYnlmauHxZmOE8qo4T3+HDg1xqKMRw/Lwxn8O5BZa24PtSVL6+pqLbbqqsZK6Gq61UTQMciNlR3JH8HNFTod8akmZMq5rTuplVYKm0OfInRvwyN4FX49nu/eptprJbKiKCKe3UcsVP7ix8DVSP5Kbcv2GcduYy5z17nK+aSJsLUXoYxFVdk8Kqqqvg7wtbPv2qqc1Z40zzn/wCd7PPuxMREfjM8ZKr9FUTiMcJ+uP8A17AAffcIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAByxgntMq/1XeP5uQ6nOWME9plX+q7x/NyGUJKVgAyQITrB2scn8TX6zSbEJ1g7WOT+Jr9ZoHV8PuUfyU8hmYQ+5R/JTyGZrZAAAAAAAAAAAAAAUvgP4xWsHiVk+wkLoKXwH8YrWDxKyfYSElV0AAqAAAAAAAAAAAAACOXb35pPCnlJEnQngI7dvfmk8KeUkSdCeA8T0f7R2h6ke2HXe6lHk+gA9s5AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADnxdFM8tNyvS4xk2PNtlfdKq4RsrrXM+VizyLI5qubKiLsrlROXQdBgDjyqdqbBmV/xpt0xN0tmZSvkndbqhGydeYr02Trq7bbbHp7D1R/O2IfR9T94Se49u7Uf9RafsHm3M4YoD2Hqj+dsQ+j6n7wimplLqGzAr869XLGJbelN/xDKainZK5nE3dGq56oi+FC6SE6wdrHJ/E1+s0o6vh9yj+SnkMzCH3KP5KeQzNbIAAAAAAAAAAAAACl8B/GK1g8Ssn2EhdBS+A/jFaweJWT7CQkqugAFQAAAAAAAAAAAAARy7e/NJ4U8pIk6E8BHbt780nhTykiToTwHiej/aO0PUj2w673Uo8n0AHtnIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAObLj27tR/1Fp+webc1Fx7d2o/6i0/YPNuZxyYhCdYO1jk/ia/WaTYhOsHaxyfxNfrNKOr4fco/kp5DMwh9yj+SnkMzWyAAAAAAAAAAAAAApfAfxitYPErJ9hIXQUvgP4xWsHiVk+wkJKroABUAAAAAAAAAAAAAEcu3vzSeFPKSJOhPAR27e/NJ4U8pIk6E8B4no/2jtD1I9sOu91KPJ9AB7ZyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADmy49u7Uf8AUWn7B5tyMZtd24lrNmtTebfd0prnTW19HNS2qoqY5Ujie1+zo2ORNl5bKamq1jxWhnjp6193pp5WOfHFLY6tjntTZFVEWPdUTdN17m6GccmKekJ1g7WOT+Jr9Zp5fVoxH++uv0JV/dkU1L1Wxq84FfrfQS3FampputxpJaamNvErm9LnMRE8KqhR3JD7lH8lPIZmEPuUfyU8hma2QAAAAAAAAAAAAAFL4D+MVrB4lZPsJC6Cl8B/GK1g8Ssn2EhJVdAAKgAAAAAAAAAAAAAjl29+aTwp5SRJ0J4CO3b35pPCnlJEnQngPE9H+0doepHth13upR5PoAPbOQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACg9WnKmtOF7Kqf/Dt1+2pC/CgtW+3Thf+nbp9tSFjmks+N35S/vIRrA93qYZQiuVU7DXu/wCJpNSE6wdrHJ/E1+s0zR1fD7lH8lPIZmEPuUfyU8hma2QAAAAAAAAAAAAAFL4D+MVrB4lZPsJC6Cl8B/GK1g8Ssn2EhJVdAAKgAAAAAAAAAAAAAjl29+aTwp5SRJ0J4CO3b35pPCnlJEnQngPE9H+0doepHth13upR5PoAPbOQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgtW+3Thf8Ap26fbUhfpQWrfbpwv/Tt0+2pCxzSX0hOsHaxyfxNfrNJsQnWDtY5P4mv1mmaOr4fco/kp5DMwh9yj+SnkMzWyAAAAAAAAAAAAAApfAfxitYPErJ9hIXQUvgP4xWsHiVk+wkJKroABUAAAAAAAAAAAAAEcu3vzSeFPKSJOhPAR27e/NJ4U8pIk6E8B4no/wBo7Q9SPbDrvdSjyfQAe2cgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHPmstZT0WsuFSVtRDTRrj10RHTSIxFXr1Jy3Vek6DNLkOH49lrIGZVYrZe2U6q6FtdRxzpGq9Kt4kXbf4hAoz0ftC9F2t6//wBuP/uQzVq82yo02yWKnuVFLK+k2axlSxznLxN5IiLzJbr3pbg9qt+ErbMPsFGtRldJBMsFshjWSNYplVjtm82qqJy6OSFd6o6eYja9PchrbbjFno6uCl44Z4aKNj43I5uyo5E3RTOJyxdqQ+5R/JTyGZhD7lH8lPIZmDIAAAAAAAAAAAAACl8B/GK1g8Ssn2EhdBS+A/jFaweJWT7CQkqugAFQAAAAAAAAAAAAARy7e/NJ4U8pIk6E8BHbt780nhTykiToTwHiej/aO0PUj2w673Uo8n0AHtnIAAAVZiWsMGR6zagaeyMgifjNPR1FPK3fimbJGjpuJVXb2DpIk5IntuZaZwpcrVkNdhFbqfgEXXb3kua3u1sem6KtDcHpb4XKqdPW5qelenc3RejcC7cX6ouhy7RnLc4fXUVijt90r7bSVklPNNDFs7/hZZGMR71/ByROdsmy8/aovKV+q/hGn9hslFluarW10lnp65lTUU8jqmvhfuiTtijZuquVrlVrW7tROaIiFM3KyUmnNp6ovBLa3rFt9IMN0tsW228bbZLRyO28NKzf41UkGmEbH64YM9zGuczRujVqqnNv/FRpyAsDMtcMepNN7fleI5NZUgvNRFT2qvr6epmpJHrKjXsekLeNjuFHtTfh2fsi942eXa86d4Lcq625Tk0FDcKBWJVUyU80skSPY17XuaxjlRnC5u7/AGqboiqi8jm++tSLqbtY4I0RkMGqFRHExE2RjUvdNsiJ3ELQsdPDLq71SHXYmScVrtDHcTUXdq2+Xdq/F8QFg2PXfTrJsopMasGV0Vxu9Yxz6WOFr3RVHC3ickc3D1t7kbzVrXKqbLunI+5Drtp3imQyWG/5RS0dyhdGypascj4qZz/aJNM1qxwqu6cnubyXcoK3RMg0P6lmaBiRStyiyta9ibKiSQVHGm6flb8++eKLLcfwLTHWjBsz39Pd4vF6fDaZYXvqLw+r3SllgaiKsjXIsaIrd+HhXfbYDs1FRyIrVRUVN0VO6fSK6Z2q42LTfD7Xf1VbtQ2Sipq1VdxL15kDGv3Xu+yReZKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKZ6or3uwH/WNH9lOVnrB2scn8TX6zSzOqK97sB/1jR/ZTlZ6wdrHJ/E1+s0zhJdXw+5R/JTyGZhD7lH8lPIZmCgAAAAAAAAAAAFO1PVBQ0tTNAunOo0qxSOZxx46rmu2VU3avHzRduSgXEUvgP4xWsHiVk+wkPvriYPg11J/hxfPK8xfVCrs2rGe5VV6c6gut1/p7dHSNZj71kasEb2v404tk5uTbZV/YRXVQKY9cTB8GupP8OL55vsO1hizG+xWlmF5pZVkje/sq7WZaenbwpvsr+JdlXuJ3RlFkgAoAAAAAAPFdrtRWK2VdzvFTHRW+jidNUTyrs2NjU3Vyqc91mquWa0tkp9I3OxfDXOdHLlNVEi1NUiLs5KSFfa91OuP/YiKfP1+0dLsuxOo1VcU0x3z+njPyZ0UVXJxTCxtR9bLFgFVFZqaGoyTLqpP+EsVtRJKh+/Q6ReiJnfc7udCKQvRbN88yLVPNrbqRLRUy0dsoKiltlAvFDRpK6VVar1Td79mpxO6OXLke/CdPLDgNLMyxUzn1lU7jrbhUvWaqq3910kq83eDo+I1uUaM4XmV7kvOQ2mSouUsbInzR1s8KuaxNmoqMeictz8e/wB0dNOvmJtzFiInlxqme6cZiIj6vqfw+dznxW9dl/8AGaTn3U8pIkVNk5ocz+ty04XmtkqfpWq+8IJq/o7h+F4U69Y1b6qiuVPcqBsUvolUP2R1VG13sXPVF3RVTmhu2D0z2VO07lFuK5q1FcYzTERE4iOPxSl7S3Ps4zj4YdqgA/a3yQH5zTMp4ZJpncMcbVe5V7iIm6qcuYjq1fbPoLDqrHRMvF9y/J2OWjrJlYxlPLXdiwwMcnuaNhY3ZdlRHOc5UcqruHU58VEcnNEVN9+ZSFo1Xy3F86vON6w0lgiggxqbI6SusSzq1sED0ZNFI2Xmr04kVHJsionQirsmht+t+oFHj2KZ/ltix+mwHJKylibS00sy3C3wVT0bTzyPd+DkT2TFc1rWqiO5KoHRwNffZ66mstxmssdLLcoqaR9KyrlWKF0qNVWo96IqtbvtuqIuyFC6Z693vINS5MFyG6YJkFVVWyesoq/E66SeKCaJWo6Cdr3Ku+zt0cipvwry334Q6KNdZb9bMipJKuxV0FwpWTyU7poHo9nXI3Kx7d05KqORUXbuopz/AKB3fVbI8ZzKe73XHrirLvd6WifUpVK9lXHUcDWq7j5UzURyNa3ZyJw8+k1GEav5VU4NofbNPbBi1rqcypLk1YKhs7aSibStVzVYjXK9eSKqoqqrl/tN3VQOqD4rWq5HK1FcnQu3NDmvJNUMxqcF1exnLrLjT8pxKzLW1jGPqFt10tksEj3KxEckrHqyORioruTtl32N2up18ii04wTS+0WluRXfGIbtK64vmWitlCyNjUVWtVZJFV7kY1OJOjmvMC+gUtlGo+d4lRYfjdZbsdrtRsruU9JRdjSTpbo4ImLJJUPRydc9ixE3Yi9Lvbcj9sXye85rdc10v1TpKClvlJbopkrLLJIyGro6lHtSWJHqr4pGPaqLu5dl2VFAuMFVdTjnNw1C0fx+7ZBIst6hSaguEipzknp5XRK9fjcjEcvxuUtUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApnqive7Af9Y0f2U5WesHaxyfxNfrNLM6or3uwH/WNH9lOVnrB2scn8TX6zTOEl1fD7lH8lPIZmEPuUfyU8hmYKAAAAAAAAAAAAAAAAAAAAAAAAAADF7GyNc17Uc1ybKipuip3ijMo0GqrDcarI9Dq+HGbrM5Zayyzoq2u4O+ONPcXr+Wz93dL1BzanTWdZamzfpiqmecTxhlTVNM5iXPOK6pU9zvC4zmFunw/Mo09naq5U2nT8unl9rMxfi5/EfjfdVKu35hccYsGE3/Ka23U8FRUvtqRK2NsqLwb8bkX+yv7i4s806xvUm0La8vtkVfC1eKCX2k1O/uPikT2THJ30XwlfaRaNXzTXPcqut2yOTJrbc6GkpqKoqk2q42wuk9hKqJs/ZHps/pXuoh+Vx/ppsunXzd4zZmJ+DM5ie7E+Hyl9H7/c3Md6M+qVlvwO5r/0033hEdSbrm2oOL+gNDpTltBLPX0cvX6lsHW2NjqGPcq8Mir0NXuHX4PQaXoJsLRaijUWbcxVRMTHxTzhpq1l6qJiZAAe9cT854WVMEsMycUcjFY5O+ipspy7hOmN4vegFs02gmpaa/YblMcVZ2W9zGuip7h2Sx6cLXL+EgdG5vLZeLpTudTGCRsbI6RrGpI9ERzkTmqJvsir+1f3gVdlulNRl2qDL7XTU3pdnw+vx+shSRyVDnVEsbt2pw8PDwNcm6rvuqclIHDozqLe8cw7AMyuOOLheM1lHLJcKKSda2509IqLBC+BzEZEq8DONySP6N0OkABCtXsKrNRtM8nxW1XH0KrLtQup4qld+FqqqLwu258LtuF23ccvSVrjWlucxahYHk12t+GWK143Q1dtdabLNO7aKaNv4Vsjomoq8cbE62rU2RXLxuVdi/wBUGl+D5pp3kmR2t6WKtwe43qtu9NVdlTNr4VqHdcWFYut8Coj1X2XH0L0b8kpluDZfpZX9TXitsSx3LKrRDf41SapmZRy7wcTk64kfGnsHLsvB09zY7FPNPbqOpq6WsqaSCarpOPsad8TXPh4k2dwOVN27pyXbpQCjIdG8tvdj1aueY11mTM87sclopoKJ0q0NvhbTyxws645vXHbulVz3cHgTlsemu0py/H7nhGV4BVWWbJrJjUeO3ShuUkrKWupk4H+wlYxXMc2Riqiqxd0dsu3dvMAUrkmBag5Q3D8snlxihz/ABW5VM9JSxS1D7fPSTxdakgfKrEkR6t2XriM2RWp7Hny/fD8Uu2I5Dm+qWq9ba6e5V1viiWltssktNbqCma56tSWRrXPc5Vc53sWpunIuMwkjZMxWSsbIxelrk3TvgVR1NWH1+FaOWCjv0DqW7Vrp7lWQPTZ0UlRM+XgVO4rWva1fjRS2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACDap6ezai2W20lDd1slfbLnDcaWqWlSoakkaObs6NVbxIqPXupz28BWt36nzLcittRar7qNSzW2rRGVUcGNsie6PdFVGv68vCvLp2XbvKdBgZHxreFqNToRNj6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH/2Q==)
"""

print('MEDIDAS DE POSICIÓN:')
media = dataset.junior_programmer_salary.mean()
print('media =', media)
print('mediana =', dataset.junior_programmer_salary.median())

Q_1 = dataset.junior_programmer_salary.quantile(0.25) #primer cuartil
print('Q_1=', Q_1)

print('Q_2 o mediana=', dataset.junior_programmer_salary.quantile(0.5)) #otra forma de calcular la mediana

Q_3 = dataset.junior_programmer_salary.quantile(0.75) #tercer cuartil
print('Q_3=', Q_3)

print('--------------')
print('MEDIDAS DE DISPERSIÓN:')
print('Rango=(max-min)=', dataset.junior_programmer_salary.max()-dataset.junior_programmer_salary.min())


desviacion = dataset.junior_programmer_salary.std() #desviación estandar
print('Desviación poblacional=', desviacion)

print('Varianza poblacional=', dataset.junior_programmer_salary.var())

RIC = Q_3-Q_1 #rango intercuartil
print('RIC=', RIC)

CV = round((desviacion / media) * 100, 2) #redondea 2 decimales
print('CV=', CV, '%')

plt.figure(figsize=(10,6))
seaborn.boxplot(data=age_data,
                 x='junior_programmer_salary',
                color=BLUE)


seaborn.despine()

plt.figure(figsize=(10,6))
seaborn.boxplot(data=age_data,
                x='age_segment', y='junior_programmer_salary',
                color=BLUE)
plt.ylabel('Promedio de estimación')
plt.xlabel('Edad')
plt.title('Comparación entre las estimaciones \n de sueldo para programadores junior')
plt.xticks(rotation=45)
seaborn.despine()

"""Con los boxplot también podemos comparar distribuciones por grupos. En este caso, si un grupo tiene una población muy reducida, su influencia visual es mucho menor ya que se traducen a cajas pequeñas o incluso sólo puntos."""

plt.figure(figsize=(10,6))
seaborn.boxplot(data=age_data,
                x='age_segment', y='junior_programmer_salary',
                hue='gender')
plt.ylabel('Distribución de estimación')
plt.xlabel('Edad')
plt.title('Comparación entre las estimaciones \n de sueldo para programadores junior')
plt.xticks(rotation=45)
plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
seaborn.despine()

"""En este gráfico podemos ver, por ejemplo, todos los outliers con sueldos mayores a 100,000, que en el otro gráfico se agrupaban dentro de la barra de desviación estándar.

## Gráficos de puntos (scatterplot)

Muestra la relación entre 2 o 3 variables numéricas continuas. Adicionalmente, se puede usar el color y la forma de los puntos para variables categóricas, y el tamaño para una variable numérica extra.

Para poder ejemplificar el gráfico de puntos, debemos encontrar dos variables numéricas continuas. Tener en cuenta que por más que una variable sea discreta, al incluirla en un scatter plot la estamos tratando como una variable continua.
"""

plt.figure(figsize=(10,6))
seaborn.scatterplot(data=dataset,
                    x='age',
                    y='junior_programmer_salary')

"""Para hacer más evidente las tendencias que pueda tener el gráico, podemos utilizar seaborn para estimar una regresión lineal con los datos, utilizando el gráfico seaborn.regplot. Sin embargo, existen maneras más efectivas de medir correlación, gráficas y analíticas, que veremos más adelante."""

plt.figure(figsize=(10,6))
seaborn.regplot(data=dataset, x='age',
                y='junior_programmer_salary')
plt.ylabel('Estimación')
plt.xlabel('Edad')
plt.title('Estimaciones de sueldo para programadores junior vs edad')
seaborn.despine()

"""## Heatmaps

Los heatmaps se utilizan para codificar la relación entre dos variables categóricas o discretas (o discretizadas). Si alguna de las variables es numérica, se puede discretizar o utilizar otro tipo de gráfico como `regplot`,  `pairplot` o `catplot`.

Por ejemplo, una pregunta posible podría ser **¿Nuestra muestra, está uniformente distribuida en cuando a género y edad?**. Para hacer el análisis más fácil, usaremos la misma separación en segmentos que en la notebook anterior.
"""

def to_categorical(column, bin_size=5, min_cut=15, max_cut=50):
    if min_cut is None:
        min_cut = int(round(column.min())) - 1
    value_max = int(numpy.ceil(column.max()))
    max_cut = min(max_cut, value_max)
    intervals = [(x, x + bin_size) for x in range(min_cut, max_cut, bin_size)]
    if max_cut != value_max:
        intervals.append((max_cut, value_max))
    print(intervals)
    return pandas.cut(column, pandas.IntervalIndex.from_tuples(intervals))

plt.figure(figsize=(10,8))
dataset = dataset[~dataset.age.isnull()]
dataset['age_segment'] = to_categorical(dataset.age)

"""En este tipo de situaciones con pocas categorías es ideal usar un heatmap. Sin embargo, no es tan intuitivo de hacer porque tenemos que pasar como argumento la matriz de co-ocurrencias ya previamente armada. Les recomendamos leer cómo funciona el comando `pandas.crosstab` para entender cómo funciona el siguiente código, aunque existen otras formas como `pivot`."""

plt.figure(figsize=(10,6))
exp = pandas.crosstab(dataset.gender, dataset.age_segment)
seaborn.heatmap(exp, annot=True)

"""## Jointplots

En caso de que querramos estimar la correlación entre variables que sean numéricas, también se puede usar el `seaborn.jointplot`, pero no siempre logra un resultado interpretable.

Volvamos al ejemplo de la estimación de salarios con respecto a la edad de la persona. Haremos un jointplot con *kind=ked* y *kind=hex*. Con ambos gráficos podemos ver mejor las distribuciones que con el regplot, ya que los puntos individuales son agregados en una función de calor. Sin embargo, sucede lo mismo que con los heatmaps: no podemos asegurar que la concentración de valores conjuntos no sea sólo producto de los valores más frecuentes de cada distribución independiente.
"""

seaborn.jointplot(data=dataset, x='age',
                  y='junior_programmer_salary', kind='kde', height=10)

fig = plt.figure(figsize=(15,6))
seaborn.jointplot(data=dataset, x='age',
                  y='junior_programmer_salary', kind='hex', height=10)

"""## Pairplots

Los pairplots son muy útiles para comparar muchas variables numéricas al mismo tiempo. Por ejemplo, se puede hacer una comparación entre la edad y ambas estimaciones de sueldo.
"""

## TODO: maybe remove outliers
seaborn.pairplot(
    data=dataset,
    vars=['age', 'junior_programmer_salary', 'senior_programmer_salary'],
    hue='gender', height=5)

"""Alumna: Maria Constanza Lobos
                              Carrera: Cs. Computacion

Respuestas:
2)
"""

import numpy as np

# Media
media = new_df['age'].mean()

# Mediana
mediana = new_df['age'].median()

# Moda
moda = new_df['age'].mode().values

# Cuartiles
q1 = new_df['age'].quantile(0.25)
q2 = new_df['age'].quantile(0.50)
q3 = new_df['age'].quantile(0.75)

# Percentiles (Ejemplo: 10%, 90%)
p10 = new_df['age'].quantile(0.10)
p90 = new_df['age'].quantile(0.90)

# Medidas de Dispersión
varianza = new_df['age'].var()
desviacion_estandar = new_df['age'].std()
rango = new_df['age'].max() - new_df['age'].min()
iqr = q3 - q1  # Rango intercuartílico

# Imprimir resultados
print(f"Media: {media:.2f}")
print(f"Mediana: {mediana:.2f}")
print(f"Moda: {moda}")
print(f"Q1 (25%): {q1:.2f}")
print(f"Q2 (50% - Mediana): {q2:.2f}")
print(f"Q3 (75%): {q3:.2f}")
print(f"Percentil 10: {p10:.2f}")
print(f"Percentil 90: {p90:.2f}")
print(f"Varianza: {varianza:.2f}")
print(f"Desviación estándar: {desviacion_estandar:.2f}")
print(f"Rango: {rango:.2f}")
print(f"Rango intercuartílico (IQR): {iqr:.2f}")

"""3)"""

probabilidades_zodiac = new_df['zodiac_sign'].value_counts(normalize=True)
print(probabilidades_zodiac)

"""4)
Describa el tipo de cada variable aleatoria y responda
Describa el tipo de cada variable aleatoria y responda

     gender: cualitativa

     age: cualitativa

     zodiac_sign: cualitativa

     profession: cualitativa

     junior_programmer_salary: cuantitativa

     senior_programmer_salary: cuantitativa

a. La variable age, ¿es discreta o continua?
   Es una variable discreta .
b. ¿Qué valores pueden tomar junior_programmer_salary y senior_programmer_salary?
  Puede tomar valores enteros o floats
c. Los signos del zodiaco siguen un orden (al igual que los días y los meses del año). ¿Podríamos decir que zodiac_sign tiene tipo ordinal?
   No. Si bien poseen un orden temporalmente, este es ciclico, por lo que no hay un signo 'mayor' o 'menor
"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
bins = [20, 30, 40, 50, 60, 70]
labels = ["20-30", "30-40", "40-50", "50-60", "60-70"]

new_df["age_range"] = pd.cut(new_df["age"], bins=bins, labels=labels, include_lowest=True)

plt.figure(figsize=(12, 6))

sns.boxplot(x="age_range", y="senior_programmer_salary", hue="gender", data=new_df, showfliers=True)
plt.ylim(0, new_df["senior_programmer_salary"].quantile(0.95))  # Hasta el percentil 95

plt.title("Distribución del Ingreso Senior por Rango de Edad y Género", fontsize=14)
plt.xlabel("Rango de Edad", fontsize=12)
plt.ylabel("Salario Senior ($)", fontsize=12)
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)
plt.legend(title="Género", fontsize=10)
plt.show()

"""5)
Mujeres:

      [20, 30], [50, 70] = sesgado a la derecha
      [45,50] = sesgado a la izquierda
      [30,40] = simetrico

    Hombres

      [15,20], [30, 35] = sesgado a la izquierda
      [20, 30] = sesgado a la derecha
      [35, 45] = simétrico
"""